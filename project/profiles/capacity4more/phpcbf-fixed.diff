--- themes/c4m/kapablo/build/Gruntfile.js
+++ PHP_CodeSniffer
@@ -108,10 +108,10 @@
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/carousel.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/collapse.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/dropdown.js',
-                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/modal.js',
+                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/modal.js',.
                        '<%= bootstrapDir %>/assets/javascripts/bootstrap/tooltip.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/popover.js',
-                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/scrollspy.js',
+                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/scrollspy.js',.
                        '<%= bootstrapDir %>/assets/javascripts/bootstrap/tab.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/transition.js'.
                   ]
@@ -133,10 +133,10 @@
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/carousel.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/collapse.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/dropdown.js',
-                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/modal.js',
+                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/modal.js',.
                        '<%= bootstrapDir %>/assets/javascripts/bootstrap/tooltip.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/popover.js',
-                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/scrollspy.js',
+                      // '<%= bootstrapDir %>/assets/javascripts/bootstrap/scrollspy.js',.
                        '<%= bootstrapDir %>/assets/javascripts/bootstrap/tab.js',
                       // '<%= bootstrapDir %>/assets/javascripts/bootstrap/transition.js'.
                   ]

--- themes/c4m/kapablo/build/node_modules/abbrev/abbrev.js
+++ PHP_CodeSniffer
@@ -1,3 +1,6 @@
+/**
+ * @file
+ */
 
 module.exports = exports = abbrev.abbrev = abbrev
 
@@ -5,12 +8,14 @@
 
 function monkeyPatch () {
   Object.defineProperty(Array.prototype, 'abbrev', {
-    value: function () { return abbrev(this) },
+    value: function () { return abbrev(this)
+    },
     enumerable: false, configurable: true, writable: true
   })
 
   Object.defineProperty(Object.prototype, 'abbrev', {
-    value: function () { return abbrev(Object.keys(this)) },
+    value: function () { return abbrev(Object.keys(this))
+    },
     enumerable: false, configurable: true, writable: true
   })
 }
@@ -19,29 +24,31 @@
   if (arguments.length !== 1 || !Array.isArray(list)) {
     list = Array.prototype.slice.call(arguments, 0)
   }
-  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {
+  for (var i = 0, l = list.length, args = []; i < l; i ++) {
     args[i] = typeof list[i] === "string" ? list[i] : String(list[i])
   }
 
-  // sort them lexicographically, so that they're next to their nearest kin
+  // Sort them lexicographically, so that they're next to their nearest kin.
   args = args.sort(lexSort)
 
-  // walk through each, seeing how much it has in common with the next and previous
+  // Walk through each, seeing how much it has in common with the next and previous.
   var abbrevs = {}
     , prev = ""
-  for (var i = 0, l = args.length ; i < l ; i ++) {
+  for (var i = 0, l = args.length; i < l; i ++) {
     var current = args[i]
       , next = args[i + 1] || ""
       , nextMatches = true
       , prevMatches = true
-    if (current === next) continue
-    for (var j = 0, cl = current.length ; j < cl ; j ++) {
-      var curChar = current.charAt(j)
-      nextMatches = nextMatches && curChar === next.charAt(j)
-      prevMatches = prevMatches && curChar === prev.charAt(j)
-      if (!nextMatches && !prevMatches) {
-        j ++
-        break
+    if (current === next) {
+      continue
+      for (var j = 0, cl = current.length; j < cl; j ++) {
+        var curChar = current.charAt(j)
+        nextMatches = nextMatches && curChar === next.charAt(j)
+        prevMatches = prevMatches && curChar === prev.charAt(j)
+        if (!nextMatches && !prevMatches) {
+          j ++
+          break
+        }
       }
     }
     prev = current
@@ -49,7 +56,7 @@
       abbrevs[current] = current
       continue
     }
-    for (var a = current.substr(0, j) ; j <= cl ; j ++) {
+    for (var a = current.substr(0, j); j <= cl; j ++) {
       abbrevs[a] = current
       a += current.charAt(j)
     }

--- themes/c4m/kapablo/build/node_modules/abbrev/test.js
+++ PHP_CodeSniffer
@@ -1,3 +1,7 @@
+/**
+ * @file
+ */
+
 var abbrev = require('./abbrev.js')
 var assert = require("assert")
 var util = require("util")
@@ -9,39 +13,39 @@
   count++
   var actual = abbrev(list)
   assert.deepEqual(actual, expect,
-    "abbrev("+util.inspect(list)+") === " + util.inspect(expect) + "\n"+
-    "actual: "+util.inspect(actual))
+    "abbrev(" + util.inspect(list) + ") === " + util.inspect(expect) + "\n" +
+    "actual: " + util.inspect(actual))
   actual = abbrev.apply(exports, list)
   assert.deepEqual(abbrev.apply(exports, list), expect,
-    "abbrev("+list.map(JSON.stringify).join(",")+") === " + util.inspect(expect) + "\n"+
-    "actual: "+util.inspect(actual))
+    "abbrev(" + list.map(JSON.stringify).join(",") + ") === " + util.inspect(expect) + "\n" +
+    "actual: " + util.inspect(actual))
   console.log('ok - ' + list.join(' '))
 }
 
 test([ "ruby", "ruby", "rules", "rules", "rules" ],
 { rub: 'ruby'
-, ruby: 'ruby'
-, rul: 'rules'
-, rule: 'rules'
-, rules: 'rules'
+  , ruby: 'ruby'
+  , rul: 'rules'
+  , rule: 'rules'
+  , rules: 'rules'
 })
 test(["fool", "foom", "pool", "pope"],
 { fool: 'fool'
-, foom: 'foom'
-, poo: 'pool'
-, pool: 'pool'
-, pop: 'pope'
-, pope: 'pope'
+  , foom: 'foom'
+  , poo: 'pool'
+  , pool: 'pool'
+  , pop: 'pope'
+  , pope: 'pope'
 })
 test(["a", "ab", "abc", "abcd", "abcde", "acde"],
 { a: 'a'
-, ab: 'ab'
-, abc: 'abc'
-, abcd: 'abcd'
-, abcde: 'abcde'
-, ac: 'acde'
-, acd: 'acde'
-, acde: 'acde'
+  , ab: 'ab'
+  , abc: 'abc'
+  , abcd: 'abcd'
+  , abcde: 'abcde'
+  , ac: 'acde'
+  , acd: 'acde'
+  , acde: 'acde'
 })
 
 console.log("1..%d", count)

--- themes/c4m/kapablo/build/node_modules/acorn/bin/build-acorn.js
+++ PHP_CodeSniffer
@@ -1,3 +1,7 @@
+/**
+ * @file
+ */
+
 var fs = require("fs"), path = require("path")
 var stream = require("stream")
 
@@ -12,7 +16,8 @@
   .transform(babelify)
   .require("./src/index.js", {entry: true})
   .bundle()
-  .on("error", function (err) { console.log("Error: " + err.message) })
+  .on("error", function (err) { console.log("Error: " + err.message)
+  })
   .pipe(fs.createWriteStream("dist/acorn.js"))
 
 var ACORN_PLACEHOLDER = "this_function_call_should_be_replaced_with_a_call_to_load_acorn()";
@@ -24,12 +29,15 @@
       if (!sent) {
         sent = true
         callback(null, ACORN_PLACEHOLDER);
-      } else {
+      }
+      else {
         callback()
       }
     }
-  } else {
-    tr._transform = function(chunk, _, callback) { callback(null, chunk) }
+  }
+  else {
+    tr._transform = function(chunk, _, callback) { callback(null, chunk)
+    }
   }
   return tr
 }
@@ -53,7 +61,8 @@
   .transform(babelify)
   .require("./src/loose/index.js", {entry: true})
   .bundle()
-  .on("error", function (err) { console.log("Error: " + err.message) })
+  .on("error", function (err) { console.log("Error: " + err.message)
+  })
   .pipe(acornShimComplete())
   .pipe(fs.createWriteStream("dist/acorn_loose.js"))
 
@@ -63,20 +72,26 @@
   .transform(babelify)
   .require("./src/walk/index.js", {entry: true})
   .bundle()
-  .on("error", function (err) { console.log("Error: " + err.message) })
+  .on("error", function (err) { console.log("Error: " + err.message)
+  })
   .pipe(acornShimComplete())
   .pipe(fs.createWriteStream("dist/walk.js"))
 
 babel.transformFile("./src/bin/acorn.js", function (err, result) {
-  if (err) return console.log("Error: " + err.message)
-  fs.writeFile("bin/acorn", result.code, function (err) {
-    if (err) return console.log("Error: " + err.message)
-
-    // Make bin/acorn executable
-    if (process.platform === 'win32')
-      return
-    var stat = fs.statSync("bin/acorn")
-    var newPerm = stat.mode | parseInt('111', 8)
-    fs.chmodSync("bin/acorn", newPerm)
+  if (err) {
+    return console.log("Error: " + err.message)
+    fs.writeFile("bin/acorn", result.code, function (err) {
+      if (err) {
+        return console.log("Error: " + err.message)
+
+        // Make bin/acorn executable.
+        if (process.platform === 'win32') {
+          return
+          var stat = fs.statSync("bin/acorn")
+          var newPerm = stat.mode | parseInt('111', 8)
+          fs.chmodSync("bin/acorn", newPerm)
+        }
+      }
+    }
   })
 })

--- themes/c4m/kapablo/build/node_modules/acorn/bin/generate-identifier-regex.js
+++ PHP_CodeSniffer
@@ -1,28 +1,42 @@
-// Which Unicode version should be used?
+/**
+ * @file
+ * Which Unicode version should be used?
+ */
+
 var version = '8.0.0';
 
 var start = require('unicode-' + version + '/properties/ID_Start/code-points')
-    .filter(function(ch) { return ch > 127; });
+    .filter(function(ch) { return ch > 127;
+    });
 var last = -1;
 var cont = [0x200c, 0x200d].concat(require('unicode-' + version + '/properties/ID_Continue/code-points')
-    .filter(function(ch) { return ch > 127 && search(start, ch, last + 1) == -1; }));
+    .filter(function(ch) { return ch > 127 && search(start, ch, last + 1) == -1;
+    }));
 
 function search(arr, ch, starting) {
-  for (var i = starting; arr[i] <= ch && i < arr.length; last = i++)
-    if (arr[i] === ch)
+  for (var i = starting; arr[i] <= ch && i < arr.length; last = i++) {
+    if (arr[i] === ch) {
       return i;
+    }
+  }
   return -1;
 }
 
 function pad(str, width) {
-  while (str.length < width) str = "0" + str;
+  while (str.length < width) {
+    str = "0" + str;
+  }
   return str;
 }
 
 function esc(code) {
   var hex = code.toString(16);
-  if (hex.length <= 2) return "\\x" + pad(hex, 2);
-  else return "\\u" + pad(hex, 4);
+  if (hex.length <= 2) {
+    return "\\x" + pad(hex, 2);
+  }
+  else {
+    return "\\u" + pad(hex, 4);
+  }
 }
 
 function generate(chars) {
@@ -34,10 +48,17 @@
       to++;
     }
     if (to <= 0xffff) {
-      if (from == to) re += esc(from);
-      else if (from + 1 == to) re += esc(from) + esc(to);
-      else re += esc(from) + "-" + esc(to);
-    } else {
+      if (from == to) {
+        re += esc(from);
+      }
+      else if (from + 1 == to) {
+        re += esc(from) + esc(to);
+      }
+      else {
+        re += esc(from) + "-" + esc(to);
+      }
+    }
+    else {
       astral.push(from - at, to - from);
       at = to;
     }

--- themes/c4m/kapablo/build/node_modules/acorn/dist/acorn.js
+++ PHP_CodeSniffer
@@ -1,924 +1,1091 @@
-(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
-// A recursive descent parser operates by defining functions for all
-// syntactic elements, and recursively calling those, each function
-// advancing the input stream and returning an AST node. Precedence
-// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
-// instead of `(!x)[1]` is handled by the fact that the parser
-// function that parses unary prefix operators is called first, and
-// in turn calls the function that parses `[]` subscripts — that
-// way, it'll receive the node for `x[1]` already parsed, and wraps
-// *that* in the unary operator node.
-//
-// Acorn uses an [operator precedence parser][opp] to handle binary
-// operator precedence, because it is much more compact than using
-// the technique outlined above, which uses different, nesting
-// functions to specify precedence, for all of the ten binary
-// precedence levels that JavaScript defines.
-//
-// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
-
-"use strict";
-
-var _tokentype = _dereq_("./tokentype");
+/**
+ * @file
+ */
+
+(function(f){if (typeof exports === "object"&&typeof module !== "undefined") {
+    module.exports = f()
+}
+else if (typeof define === "function"&&define.amd) {
+  define([],f)
+}
+else {
+  var g;if (typeof window !== "undefined") {
+    g = window
+  }
+  else if (typeof global !== "undefined") {
+    g = global
+  }
+  else if (typeof self !== "undefined") {
+    g = self
+  }
+  else {
+    g = this
+  }g.acorn = f()
+}
+})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if (!n[o]) {
+        if (!t[o]) {
+          var a = typeof require == "function"&&require;if (!u&&a) {
+            return a(o,!0);
+          }if (i) {
+            return i(o,!0);
+          }var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND",f
+        }var l = n[o] = {exports:{}};t[o][0].call(l.exports,function(e){var n = t[o][1][e];return s(n ? n : e)
+        },l,l.exports,e,t,n,r)
+}return n[o].exports
+}var i = typeof require == "function"&&require;for (var o = 0; o < r.length; o++) {
+  s(r[o]);return s
+})(1 :[function(_dereq_,module,exports){
+  // A recursive descent parser operates by defining functions for all
+  // syntactic elements, and recursively calling those, each function
+  // advancing the input stream and returning an AST node. Precedence
+  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
+  // instead of `(!x)[1]` is handled by the fact that the parser
+  // function that parses unary prefix operators is called first, and
+  // in turn calls the function that parses `[]` subscripts — that
+  // way, it'll receive the node for `x[1]` already parsed, and wraps
+  // *that* in the unary operator node.
+  //
+  // Acorn uses an [operator precedence parser][opp] to handle binary
+  // operator precedence, because it is much more compact than using
+  // the technique outlined above, which uses different, nesting
+  // functions to specify precedence, for all of the ten binary
+  // precedence levels that JavaScript defines.
+  //
+  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
+  "use strict";
 
-var _state = _dereq_("./state");
+  var _tokentype = _dereq_("./tokentype");
 
-var pp = _state.Parser.prototype;
+  var _state = _dereq_("./state");
 
-// Check if property name clashes with already added.
-// Object/class getters and setters are not allowed to clash —
-// either with each other or with an init property — and in
-// strict mode, init properties are also not allowed to be repeated.
+  var pp = _state.Parser.prototype;
 
-pp.checkPropClash = function (prop, propHash) {
-  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
-  var key = prop.key;var name = undefined;
-  switch (key.type) {
-    case "Identifier":
-      name = key.name;break;
-    case "Literal":
-      name = String(key.value);break;
-    default:
+  // Check if property name clashes with already added.
+  // Object/class getters and setters are not allowed to clash —
+  // either with each other or with an init property — and in
+  // strict mode, init properties are also not allowed to be repeated.
+  pp.checkPropClash = function (prop, propHash) {
+    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
       return;
-  }
-  var kind = prop.kind;
-
-  if (this.options.ecmaVersion >= 6) {
-    if (name === "__proto__" && kind === "init") {
-      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
-      propHash.proto = true;
     }
-    return;
-  }
-  name = "$" + name;
-  var other = propHash[name];
-  if (other) {
-    var isGetSet = kind !== "init";
-    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
-  } else {
-    other = propHash[name] = {
-      init: false,
-      get: false,
-      set: false
-    };
-  }
-  other[kind] = true;
-};
-
-// ### Expression parsing
-
-// These nest, from the most general expression type at the top to
-// 'atomic', nondivisible expression types at the bottom. Most of
-// the functions will simply let the function(s) below them parse,
-// and, *if* the syntactic construct they handle is present, wrap
-// the AST node that the inner parser gave them in another node.
-
-// Parse a full expression. The optional arguments are used to
-// forbid the `in` operator (in for loops initalization expressions)
-// and provide reference for storing '=' operator inside shorthand
-// property assignment in contexts where both object expression
-// and object pattern might appear (so it's possible to raise
-// delayed syntax error at correct position).
+    var key = prop.key;var name = undefined;
+    switch (key.type) {
+      case "Identifier":
+        name = key.name;
+        break;
 
-pp.parseExpression = function (noIn, refDestructuringErrors) {
-  var startPos = this.start,
-      startLoc = this.startLoc;
-  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
-  if (this.type === _tokentype.types.comma) {
-    var node = this.startNodeAt(startPos, startLoc);
-    node.expressions = [expr];
-    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
-    return this.finishNode(node, "SequenceExpression");
-  }
-  return expr;
-};
+      case "Literal":
+        name = String(key.value);
+        break;
 
-// Parse an assignment expression. This includes applications of
-// operators like `+=`.
+      default:
+        return;
+    }
+    var kind = prop.kind;
 
-pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
-  if (this.inGenerator && this.isContextual("yield")) return this.parseYield();
+    if (this.options.ecmaVersion >= 6) {
+      if (name === "__proto__" && kind === "init") {
+        if (propHash.proto) {
+          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
+        }
+        propHash.proto = true;
+      }
+      return;
+    }
+    name = "$" + name;
+    var other = propHash[name];
+    if (other) {
+      var isGetSet = kind !== "init";
+      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) {
+        this.raiseRecoverable(key.start, "Redefinition of property");
+      }
+    }
+    else {
+      other = propHash[name] = {
+        init: false,
+        get: false,
+        set: false
+          };
+    }
+    other[kind] = true;
+  };
 
-  var validateDestructuring = false;
-  if (!refDestructuringErrors) {
-    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
-    validateDestructuring = true;
-  }
-  var startPos = this.start,
+  // ### Expression parsing
+  // These nest, from the most general expression type at the top to
+  // 'atomic', nondivisible expression types at the bottom. Most of
+  // the functions will simply let the function(s) below them parse,
+  // and, *if* the syntactic construct they handle is present, wrap
+  // the AST node that the inner parser gave them in another node.
+  // Parse a full expression. The optional arguments are used to
+  // forbid the `in` operator (in for loops initalization expressions)
+  // and provide reference for storing '=' operator inside shorthand
+  // property assignment in contexts where both object expression
+  // and object pattern might appear (so it's possible to raise
+  // delayed syntax error at correct position).
+  pp.parseExpression = function (noIn, refDestructuringErrors) {
+    var startPos = this.start,
       startLoc = this.startLoc;
-  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
-  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
-  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
-  if (this.type.isAssign) {
-    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
-    var node = this.startNodeAt(startPos, startLoc);
-    node.operator = this.value;
-    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
-    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
-    this.checkLVal(left);
-    this.next();
-    node.right = this.parseMaybeAssign(noIn);
-    return this.finishNode(node, "AssignmentExpression");
-  } else {
-    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
-  }
-  return left;
-};
+    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
+    if (this.type === _tokentype.types.comma) {
+      var node = this.startNodeAt(startPos, startLoc);
+      node.expressions = [expr];
+      while (this.eat(_tokentype.types.comma)) {
+        node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
+      }
+      return this.finishNode(node, "SequenceExpression");
+    }
+    return expr;
+  };
 
-// Parse a ternary conditional (`?:`) operator.
+  // Parse an assignment expression. This includes applications of
+  // operators like `+=`.
+  pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
+    if (this.inGenerator && this.isContextual("yield")) {
+      return this.parseYield();
+    }
 
-pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
-  var startPos = this.start,
+    var validateDestructuring = false;
+    if (!refDestructuringErrors) {
+      refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
+      validateDestructuring = true;
+    }
+    var startPos = this.start,
       startLoc = this.startLoc;
-  var expr = this.parseExprOps(noIn, refDestructuringErrors);
-  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
-  if (this.eat(_tokentype.types.question)) {
-    var node = this.startNodeAt(startPos, startLoc);
-    node.test = expr;
-    node.consequent = this.parseMaybeAssign();
-    this.expect(_tokentype.types.colon);
-    node.alternate = this.parseMaybeAssign(noIn);
-    return this.finishNode(node, "ConditionalExpression");
-  }
-  return expr;
-};
+    if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) {
+      this.potentialArrowAt = this.start;
+    }
+    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
+    if (afterLeftParse) {
+      left = afterLeftParse.call(this, left, startPos, startLoc);
+    }
+    if (this.type.isAssign) {
+      if (validateDestructuring) {
+        this.checkPatternErrors(refDestructuringErrors, true);
+      }
+      var node = this.startNodeAt(startPos, startLoc);
+      node.operator = this.value;
+      node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
+      // Reset because shorthand default was used correctly.
+      refDestructuringErrors.shorthandAssign = 0;
+      this.checkLVal(left);
+      this.next();
+      node.right = this.parseMaybeAssign(noIn);
+      return this.finishNode(node, "AssignmentExpression");
+    }
+    else {
+      if (validateDestructuring) {
+        this.checkExpressionErrors(refDestructuringErrors, true);
+      }
+    }
+    return left;
+  };
 
-// Start the precedence parser.
+  // Parse a ternary conditional (`?:`) operator.
+  pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
+    var startPos = this.start,
+      startLoc = this.startLoc;
+    var expr = this.parseExprOps(noIn, refDestructuringErrors);
+    if (this.checkExpressionErrors(refDestructuringErrors)) {
+      return expr;
+    }
+    if (this.eat(_tokentype.types.question)) {
+      var node = this.startNodeAt(startPos, startLoc);
+      node.test = expr;
+      node.consequent = this.parseMaybeAssign();
+      this.expect(_tokentype.types.colon);
+      node.alternate = this.parseMaybeAssign(noIn);
+      return this.finishNode(node, "ConditionalExpression");
+    }
+    return expr;
+  };
 
-pp.parseExprOps = function (noIn, refDestructuringErrors) {
-  var startPos = this.start,
+  // Start the precedence parser.
+  pp.parseExprOps = function (noIn, refDestructuringErrors) {
+    var startPos = this.start,
       startLoc = this.startLoc;
-  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
-  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
-  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
-};
-
-// Parse binary operators with the operator precedence parsing
-// algorithm. `left` is the left-hand side of the operator.
-// `minPrec` provides context that allows the function to stop and
-// defer further parser to one of its callers when it encounters an
-// operator that has a lower precedence than the set it is parsing.
-
-pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
-  var prec = this.type.binop;
-  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
-    if (prec > minPrec) {
-      var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
-      var op = this.value;
-      this.next();
-      var startPos = this.start,
-          startLoc = this.startLoc;
-      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
-      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
-      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
+    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
+    if (this.checkExpressionErrors(refDestructuringErrors)) {
+      return expr;
     }
-  }
-  return left;
-};
+    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
+  };
 
-pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
-  var node = this.startNodeAt(startPos, startLoc);
-  node.left = left;
-  node.operator = op;
-  node.right = right;
-  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
-};
+  // Parse binary operators with the operator precedence parsing
+  // algorithm. `left` is the left-hand side of the operator.
+  // `minPrec` provides context that allows the function to stop and
+  // defer further parser to one of its callers when it encounters an
+  // operator that has a lower precedence than the set it is parsing.
+  pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
+    var prec = this.type.binop;
+    if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
+      if (prec > minPrec) {
+        var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
+        var op = this.value;
+        this.next();
+        var startPos = this.start,
+          startLoc = this.startLoc;
+        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
+        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
+        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
+      }
+    }
+    return left;
+  };
 
-// Parse unary operators, both prefix and postfix.
+  pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
+    var node = this.startNodeAt(startPos, startLoc);
+    node.left = left;
+    node.operator = op;
+    node.right = right;
+    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
+  };
 
-pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
-  var startPos = this.start,
+  // Parse unary operators, both prefix and postfix.
+  pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
+    var startPos = this.start,
       startLoc = this.startLoc,
       expr = undefined;
-  if (this.type.prefix) {
-    var node = this.startNode(),
+    if (this.type.prefix) {
+      var node = this.startNode(),
         update = this.type === _tokentype.types.incDec;
-    node.operator = this.value;
-    node.prefix = true;
-    this.next();
-    node.argument = this.parseMaybeUnary(null, true);
-    this.checkExpressionErrors(refDestructuringErrors, true);
-    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
-    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
-  } else {
-    expr = this.parseExprSubscripts(refDestructuringErrors);
-    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
-    while (this.type.postfix && !this.canInsertSemicolon()) {
-      var node = this.startNodeAt(startPos, startLoc);
       node.operator = this.value;
-      node.prefix = false;
-      node.argument = expr;
-      this.checkLVal(expr);
+      node.prefix = true;
       this.next();
-      expr = this.finishNode(node, "UpdateExpression");
+      node.argument = this.parseMaybeUnary(null, true);
+      this.checkExpressionErrors(refDestructuringErrors, true);
+      if (update) {
+        this.checkLVal(node.argument);
+      }
+      else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
+        this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
+      }
+      else {
+        sawUnary = true;
+      }
+      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
+    }
+    else {
+      expr = this.parseExprSubscripts(refDestructuringErrors);
+      if (this.checkExpressionErrors(refDestructuringErrors)) {
+        return expr;
+      }
+      while (this.type.postfix && !this.canInsertSemicolon()) {
+        var node = this.startNodeAt(startPos, startLoc);
+        node.operator = this.value;
+        node.prefix = false;
+        node.argument = expr;
+        this.checkLVal(expr);
+        this.next();
+        expr = this.finishNode(node, "UpdateExpression");
+      }
     }
-  }
-
-  if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
-};
 
-// Parse call, dot, and `[]`-subscript expressions.
+    if (!sawUnary && this.eat(_tokentype.types.starstar)) {
+      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
+    }
+    else {
+      return expr;
+    }
+  };
 
-pp.parseExprSubscripts = function (refDestructuringErrors) {
-  var startPos = this.start,
+  // Parse call, dot, and `[]`-subscript expressions.
+  pp.parseExprSubscripts = function (refDestructuringErrors) {
+    var startPos = this.start,
       startLoc = this.startLoc;
-  var expr = this.parseExprAtom(refDestructuringErrors);
-  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
-  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
-  return this.parseSubscripts(expr, startPos, startLoc);
-};
-
-pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
-  for (;;) {
-    if (this.eat(_tokentype.types.dot)) {
-      var node = this.startNodeAt(startPos, startLoc);
-      node.object = base;
-      node.property = this.parseIdent(true);
-      node.computed = false;
-      base = this.finishNode(node, "MemberExpression");
-    } else if (this.eat(_tokentype.types.bracketL)) {
-      var node = this.startNodeAt(startPos, startLoc);
-      node.object = base;
-      node.property = this.parseExpression();
-      node.computed = true;
-      this.expect(_tokentype.types.bracketR);
-      base = this.finishNode(node, "MemberExpression");
-    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
-      var node = this.startNodeAt(startPos, startLoc);
-      node.callee = base;
-      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
-      base = this.finishNode(node, "CallExpression");
-    } else if (this.type === _tokentype.types.backQuote) {
-      var node = this.startNodeAt(startPos, startLoc);
-      node.tag = base;
-      node.quasi = this.parseTemplate();
-      base = this.finishNode(node, "TaggedTemplateExpression");
-    } else {
-      return base;
+    var expr = this.parseExprAtom(refDestructuringErrors);
+    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
+    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
+      return expr;
     }
-  }
-};
+    return this.parseSubscripts(expr, startPos, startLoc);
+  };
 
-// Parse an atomic expression — either a single token that is an
-// expression, an expression started by a keyword like `function` or
-// `new`, or an expression wrapped in punctuation like `()`, `[]`,
-// or `{}`.
+  pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
+    for (;;) {
+      if (this.eat(_tokentype.types.dot)) {
+        var node = this.startNodeAt(startPos, startLoc);
+        node.object = base;
+        node.property = this.parseIdent(true);
+        node.computed = false;
+        base = this.finishNode(node, "MemberExpression");
+      }
+      else if (this.eat(_tokentype.types.bracketL)) {
+        var node = this.startNodeAt(startPos, startLoc);
+        node.object = base;
+        node.property = this.parseExpression();
+        node.computed = true;
+        this.expect(_tokentype.types.bracketR);
+        base = this.finishNode(node, "MemberExpression");
+      }
+      else if (!noCalls && this.eat(_tokentype.types.parenL)) {
+        var node = this.startNodeAt(startPos, startLoc);
+        node.callee = base;
+        node.arguments = this.parseExprList(_tokentype.types.parenR, false);
+        base = this.finishNode(node, "CallExpression");
+      }
+      else if (this.type === _tokentype.types.backQuote) {
+        var node = this.startNodeAt(startPos, startLoc);
+        node.tag = base;
+        node.quasi = this.parseTemplate();
+        base = this.finishNode(node, "TaggedTemplateExpression");
+      }
+      else {
+        return base;
+      }
+    }
+  };
 
-pp.parseExprAtom = function (refDestructuringErrors) {
-  var node = undefined,
+  // Parse an atomic expression — either a single token that is an
+  // expression, an expression started by a keyword like `function` or
+  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
+  // or `{}`.
+  pp.parseExprAtom = function (refDestructuringErrors) {
+    var node = undefined,
       canBeArrow = this.potentialArrowAt == this.start;
-  switch (this.type) {
-    case _tokentype.types._super:
-      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
+    switch (this.type) {
+      case _tokentype.types._super:
+        if (!this.inFunction) {
+          this.raise(this.start, "'super' outside of function or class");
+        }
 
-    case _tokentype.types._this:
-      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
-      node = this.startNode();
-      this.next();
-      return this.finishNode(node, type);
+      case _tokentype.types._this:
+        var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
+        node = this.startNode();
+        this.next();
+        return this.finishNode(node, type);
 
-    case _tokentype.types.name:
-      var startPos = this.start,
+      case _tokentype.types.name:
+        var startPos = this.start,
           startLoc = this.startLoc;
-      var id = this.parseIdent(this.type !== _tokentype.types.name);
-      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
-      return id;
-
-    case _tokentype.types.regexp:
-      var value = this.value;
-      node = this.parseLiteral(value.value);
-      node.regex = { pattern: value.pattern, flags: value.flags };
-      return node;
-
-    case _tokentype.types.num:case _tokentype.types.string:
-      return this.parseLiteral(this.value);
-
-    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
-      node = this.startNode();
-      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
-      node.raw = this.type.keyword;
-      this.next();
-      return this.finishNode(node, "Literal");
-
-    case _tokentype.types.parenL:
-      return this.parseParenAndDistinguishExpression(canBeArrow);
-
-    case _tokentype.types.bracketL:
-      node = this.startNode();
-      this.next();
-      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
-      return this.finishNode(node, "ArrayExpression");
-
-    case _tokentype.types.braceL:
-      return this.parseObj(false, refDestructuringErrors);
+        var id = this.parseIdent(this.type !== _tokentype.types.name);
+        if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
+          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
+        }
+        return id;
 
-    case _tokentype.types._function:
-      node = this.startNode();
-      this.next();
-      return this.parseFunction(node, false);
+      case _tokentype.types.regexp:
+        var value = this.value;
+        node = this.parseLiteral(value.value);
+        node.regex = { pattern: value.pattern, flags: value.flags };
+        return node;
+
+      case _tokentype.types.num:case _tokentype.types.string:
+        return this.parseLiteral(this.value);
+
+      case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
+            node = this.startNode();
+            node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
+            node.raw = this.type.keyword;
+            this.next();
+        return this.finishNode(node, "Literal");
+
+      case _tokentype.types.parenL:
+        return this.parseParenAndDistinguishExpression(canBeArrow);
+
+      case _tokentype.types.bracketL:
+        node = this.startNode();
+        this.next();
+        node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
+        return this.finishNode(node, "ArrayExpression");
+
+      case _tokentype.types.braceL:
+        return this.parseObj(false, refDestructuringErrors);
+
+      case _tokentype.types._function:
+        node = this.startNode();
+        this.next();
+        return this.parseFunction(node, false);
 
-    case _tokentype.types._class:
-      return this.parseClass(this.startNode(), false);
+      case _tokentype.types._class:
+        return this.parseClass(this.startNode(), false);
 
-    case _tokentype.types._new:
-      return this.parseNew();
+      case _tokentype.types._new:
+        return this.parseNew();
 
-    case _tokentype.types.backQuote:
-      return this.parseTemplate();
+      case _tokentype.types.backQuote:
+        return this.parseTemplate();
 
-    default:
-      this.unexpected();
-  }
-};
+      default:
+        this.unexpected();
+    }
+  };
 
-pp.parseLiteral = function (value) {
-  var node = this.startNode();
-  node.value = value;
-  node.raw = this.input.slice(this.start, this.end);
-  this.next();
-  return this.finishNode(node, "Literal");
-};
+  pp.parseLiteral = function (value) {
+    var node = this.startNode();
+    node.value = value;
+    node.raw = this.input.slice(this.start, this.end);
+    this.next();
+    return this.finishNode(node, "Literal");
+  };
 
-pp.parseParenExpression = function () {
-  this.expect(_tokentype.types.parenL);
-  var val = this.parseExpression();
-  this.expect(_tokentype.types.parenR);
-  return val;
-};
+  pp.parseParenExpression = function () {
+    this.expect(_tokentype.types.parenL);
+    var val = this.parseExpression();
+    this.expect(_tokentype.types.parenR);
+    return val;
+  };
 
-pp.parseParenAndDistinguishExpression = function (canBeArrow) {
-  var startPos = this.start,
+  pp.parseParenAndDistinguishExpression = function (canBeArrow) {
+    var startPos = this.start,
       startLoc = this.startLoc,
       val = undefined;
-  if (this.options.ecmaVersion >= 6) {
-    this.next();
+    if (this.options.ecmaVersion >= 6) {
+      this.next();
 
-    var innerStartPos = this.start,
+      var innerStartPos = this.start,
         innerStartLoc = this.startLoc;
-    var exprList = [],
+      var exprList = [],
         first = true;
-    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
+      var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
         spreadStart = undefined,
         innerParenStart = undefined;
-    while (this.type !== _tokentype.types.parenR) {
-      first ? first = false : this.expect(_tokentype.types.comma);
-      if (this.type === _tokentype.types.ellipsis) {
-        spreadStart = this.start;
-        exprList.push(this.parseParenItem(this.parseRest()));
-        break;
-      } else {
-        if (this.type === _tokentype.types.parenL && !innerParenStart) {
-          innerParenStart = this.start;
+      while (this.type !== _tokentype.types.parenR) {
+        first ? first = false : this.expect(_tokentype.types.comma);
+        if (this.type === _tokentype.types.ellipsis) {
+          spreadStart = this.start;
+          exprList.push(this.parseParenItem(this.parseRest()));
+          break;
+        }
+        else {
+          if (this.type === _tokentype.types.parenL && !innerParenStart) {
+            innerParenStart = this.start;
+          }
+          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
         }
-        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
       }
-    }
-    var innerEndPos = this.start,
+      var innerEndPos = this.start,
         innerEndLoc = this.startLoc;
-    this.expect(_tokentype.types.parenR);
+      this.expect(_tokentype.types.parenR);
 
-    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
-      this.checkPatternErrors(refDestructuringErrors, true);
-      if (innerParenStart) this.unexpected(innerParenStart);
-      return this.parseParenArrowList(startPos, startLoc, exprList);
-    }
+      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
+        this.checkPatternErrors(refDestructuringErrors, true);
+        if (innerParenStart) {
+          this.unexpected(innerParenStart);
+        }
+        return this.parseParenArrowList(startPos, startLoc, exprList);
+      }
 
-    if (!exprList.length) this.unexpected(this.lastTokStart);
-    if (spreadStart) this.unexpected(spreadStart);
-    this.checkExpressionErrors(refDestructuringErrors, true);
+      if (!exprList.length) {
+        this.unexpected(this.lastTokStart);
+      }
+      if (spreadStart) {
+        this.unexpected(spreadStart);
+      }
+      this.checkExpressionErrors(refDestructuringErrors, true);
 
-    if (exprList.length > 1) {
-      val = this.startNodeAt(innerStartPos, innerStartLoc);
-      val.expressions = exprList;
-      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
-    } else {
-      val = exprList[0];
-    }
-  } else {
-    val = this.parseParenExpression();
-  }
-
-  if (this.options.preserveParens) {
-    var par = this.startNodeAt(startPos, startLoc);
-    par.expression = val;
-    return this.finishNode(par, "ParenthesizedExpression");
-  } else {
-    return val;
-  }
-};
+      if (exprList.length > 1) {
+        val = this.startNodeAt(innerStartPos, innerStartLoc);
+        val.expressions = exprList;
+        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
+      }
+      else {
+        val = exprList[0];
+      }
+    }
+    else {
+      val = this.parseParenExpression();
+    }
 
-pp.parseParenItem = function (item) {
-  return item;
-};
+    if (this.options.preserveParens) {
+      var par = this.startNodeAt(startPos, startLoc);
+      par.expression = val;
+      return this.finishNode(par, "ParenthesizedExpression");
+    }
+    else {
+      return val;
+    }
+  };
 
-pp.parseParenArrowList = function (startPos, startLoc, exprList) {
-  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
-};
+  pp.parseParenItem = function (item) {
+    return item;
+  };
 
-// New's precedence is slightly tricky. It must allow its argument to
-// be a `[]` or dot subscript expression, but not a call — at least,
-// not without wrapping it in parentheses. Thus, it uses the noCalls
-// argument to parseSubscripts to prevent it from consuming the
-// argument list.
+  pp.parseParenArrowList = function (startPos, startLoc, exprList) {
+    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
+  };
 
-var empty = [];
+  // New's precedence is slightly tricky. It must allow its argument to
+  // be a `[]` or dot subscript expression, but not a call — at least,
+  // not without wrapping it in parentheses. Thus, it uses the noCalls
+  // argument to parseSubscripts to prevent it from consuming the
+  // argument list.
+  var empty = [];
 
-pp.parseNew = function () {
-  var node = this.startNode();
-  var meta = this.parseIdent(true);
-  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
-    node.meta = meta;
-    node.property = this.parseIdent(true);
-    if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
-    if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
-    return this.finishNode(node, "MetaProperty");
-  }
-  var startPos = this.start,
+  pp.parseNew = function () {
+    var node = this.startNode();
+    var meta = this.parseIdent(true);
+    if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
+      node.meta = meta;
+      node.property = this.parseIdent(true);
+      if (node.property.name !== "target") {
+        this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
+      }
+      if (!this.inFunction) {
+        this.raiseRecoverable(node.start, "new.target can only be used in functions");
+      }
+      return this.finishNode(node, "MetaProperty");
+    }
+    var startPos = this.start,
       startLoc = this.startLoc;
-  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
-  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
-  return this.finishNode(node, "NewExpression");
-};
-
-// Parse template expression.
-
-pp.parseTemplateElement = function () {
-  var elem = this.startNode();
-  elem.value = {
-    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
-    cooked: this.value
+    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
+    if (this.eat(_tokentype.types.parenL)) {
+      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
+    }
+    else {
+      node.arguments = empty;
+    }
+    return this.finishNode(node, "NewExpression");
   };
-  this.next();
-  elem.tail = this.type === _tokentype.types.backQuote;
-  return this.finishNode(elem, "TemplateElement");
-};
 
-pp.parseTemplate = function () {
-  var node = this.startNode();
-  this.next();
-  node.expressions = [];
-  var curElt = this.parseTemplateElement();
-  node.quasis = [curElt];
-  while (!curElt.tail) {
-    this.expect(_tokentype.types.dollarBraceL);
-    node.expressions.push(this.parseExpression());
-    this.expect(_tokentype.types.braceR);
-    node.quasis.push(curElt = this.parseTemplateElement());
-  }
-  this.next();
-  return this.finishNode(node, "TemplateLiteral");
-};
+  // Parse template expression.
+  pp.parseTemplateElement = function () {
+    var elem = this.startNode();
+    elem.value = {
+      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
+      cooked: this.value
+    };
+    this.next();
+    elem.tail = this.type === _tokentype.types.backQuote;
+    return this.finishNode(elem, "TemplateElement");
+  };
 
-// Parse an object literal or binding pattern.
+  pp.parseTemplate = function () {
+    var node = this.startNode();
+    this.next();
+    node.expressions = [];
+    var curElt = this.parseTemplateElement();
+    node.quasis = [curElt];
+    while (!curElt.tail) {
+      this.expect(_tokentype.types.dollarBraceL);
+      node.expressions.push(this.parseExpression());
+      this.expect(_tokentype.types.braceR);
+      node.quasis.push(curElt = this.parseTemplateElement());
+    }
+    this.next();
+    return this.finishNode(node, "TemplateLiteral");
+  };
 
-pp.parseObj = function (isPattern, refDestructuringErrors) {
-  var node = this.startNode(),
+  // Parse an object literal or binding pattern.
+  pp.parseObj = function (isPattern, refDestructuringErrors) {
+    var node = this.startNode(),
       first = true,
       propHash = {};
-  node.properties = [];
-  this.next();
-  while (!this.eat(_tokentype.types.braceR)) {
-    if (!first) {
-      this.expect(_tokentype.types.comma);
-      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
-    } else first = false;
+    node.properties = [];
+    this.next();
+    while (!this.eat(_tokentype.types.braceR)) {
+      if (!first) {
+        this.expect(_tokentype.types.comma);
+        if (this.afterTrailingComma(_tokentype.types.braceR)) {
+          break;
+        }
+      }
+      else {
+        first = false;
+      }
 
-    var prop = this.startNode(),
+      var prop = this.startNode(),
         isGenerator = undefined,
         startPos = undefined,
         startLoc = undefined;
-    if (this.options.ecmaVersion >= 6) {
-      prop.method = false;
-      prop.shorthand = false;
-      if (isPattern || refDestructuringErrors) {
-        startPos = this.start;
-        startLoc = this.startLoc;
-      }
-      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
-    }
-    this.parsePropertyName(prop);
-    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
-    this.checkPropClash(prop, propHash);
-    node.properties.push(this.finishNode(prop, "Property"));
-  }
-  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
-};
-
-pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
-  if (this.eat(_tokentype.types.colon)) {
-    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
-    prop.kind = "init";
-  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
-    if (isPattern) this.unexpected();
-    prop.kind = "init";
-    prop.method = true;
-    prop.value = this.parseMethod(isGenerator);
-  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR) {
-    if (isGenerator || isPattern) this.unexpected();
-    prop.kind = prop.key.name;
-    this.parsePropertyName(prop);
-    prop.value = this.parseMethod(false);
-    var paramCount = prop.kind === "get" ? 0 : 1;
-    if (prop.value.params.length !== paramCount) {
-      var start = prop.value.start;
-      if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
-    }
-    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
-  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
-    prop.kind = "init";
-    if (isPattern) {
-      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
-      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
-    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
-      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
-      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
-    } else {
-      prop.value = prop.key;
+      if (this.options.ecmaVersion >= 6) {
+        prop.method = false;
+        prop.shorthand = false;
+        if (isPattern || refDestructuringErrors) {
+          startPos = this.start;
+          startLoc = this.startLoc;
+        }
+        if (!isPattern) {
+          isGenerator = this.eat(_tokentype.types.star);
+        }
+      }
+      this.parsePropertyName(prop);
+      this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
+      this.checkPropClash(prop, propHash);
+      node.properties.push(this.finishNode(prop, "Property"));
     }
-    prop.shorthand = true;
-  } else this.unexpected();
-};
+    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
+  };
 
-pp.parsePropertyName = function (prop) {
-  if (this.options.ecmaVersion >= 6) {
-    if (this.eat(_tokentype.types.bracketL)) {
-      prop.computed = true;
-      prop.key = this.parseMaybeAssign();
-      this.expect(_tokentype.types.bracketR);
-      return prop.key;
-    } else {
-      prop.computed = false;
+  pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
+    if (this.eat(_tokentype.types.colon)) {
+      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
+      prop.kind = "init";
+    }
+    else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
+      if (isPattern) {
+        this.unexpected();
+      }
+      prop.kind = "init";
+      prop.method = true;
+      prop.value = this.parseMethod(isGenerator);
+    }
+    else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR) {
+      if (isGenerator || isPattern) {
+        this.unexpected();
+      }
+      prop.kind = prop.key.name;
+      this.parsePropertyName(prop);
+      prop.value = this.parseMethod(false);
+      var paramCount = prop.kind === "get" ? 0 : 1;
+      if (prop.value.params.length !== paramCount) {
+        var start = prop.value.start;
+        if (prop.kind === "get") {
+          this.raiseRecoverable(start, "getter should have no params");
+        }
+        else {
+          this.raiseRecoverable(start, "setter should have exactly one param");
+        }
+      }
+      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
+        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
+      }
     }
-  }
-  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
-};
-
-// Initialize empty function node.
+    else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
+      prop.kind = "init";
+      if (isPattern) {
+        if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") {
+          this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
+        }
+        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
+      }
+      else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
+        if (!refDestructuringErrors.shorthandAssign) {
+          refDestructuringErrors.shorthandAssign = this.start;
+        }
+        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
+      }
+      else {
+        prop.value = prop.key;
+      }
+      prop.shorthand = true;
+    }
+    else {
+      this.unexpected();
+    }
+  };
 
-pp.initFunction = function (node) {
-  node.id = null;
-  if (this.options.ecmaVersion >= 6) {
-    node.generator = false;
-    node.expression = false;
-  }
-};
+  pp.parsePropertyName = function (prop) {
+    if (this.options.ecmaVersion >= 6) {
+      if (this.eat(_tokentype.types.bracketL)) {
+        prop.computed = true;
+        prop.key = this.parseMaybeAssign();
+        this.expect(_tokentype.types.bracketR);
+        return prop.key;
+      }
+      else {
+        prop.computed = false;
+      }
+    }
+    return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
+  };
 
-// Parse object or class method.
+  // Initialize empty function node.
+  pp.initFunction = function (node) {
+    node.id = null;
+    if (this.options.ecmaVersion >= 6) {
+      node.generator = false;
+      node.expression = false;
+    }
+  };
 
-pp.parseMethod = function (isGenerator) {
-  var node = this.startNode(),
+  // Parse object or class method.
+  pp.parseMethod = function (isGenerator) {
+    var node = this.startNode(),
       oldInGen = this.inGenerator;
-  this.inGenerator = isGenerator;
-  this.initFunction(node);
-  this.expect(_tokentype.types.parenL);
-  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
-  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
-  this.parseFunctionBody(node, false);
-  this.inGenerator = oldInGen;
-  return this.finishNode(node, "FunctionExpression");
-};
-
-// Parse arrow function expression with given parameters.
-
-pp.parseArrowExpression = function (node, params) {
-  var oldInGen = this.inGenerator;
-  this.inGenerator = false;
-  this.initFunction(node);
-  node.params = this.toAssignableList(params, true);
-  this.parseFunctionBody(node, true);
-  this.inGenerator = oldInGen;
-  return this.finishNode(node, "ArrowFunctionExpression");
-};
-
-// Parse function body and check parameters.
+    this.inGenerator = isGenerator;
+    this.initFunction(node);
+    this.expect(_tokentype.types.parenL);
+    node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
+    if (this.options.ecmaVersion >= 6) {
+      node.generator = isGenerator;
+    }
+    this.parseFunctionBody(node, false);
+    this.inGenerator = oldInGen;
+    return this.finishNode(node, "FunctionExpression");
+  };
 
-pp.parseFunctionBody = function (node, isArrowFunction) {
-  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;
+  // Parse arrow function expression with given parameters.
+  pp.parseArrowExpression = function (node, params) {
+    var oldInGen = this.inGenerator;
+    this.inGenerator = false;
+    this.initFunction(node);
+    node.params = this.toAssignableList(params, true);
+    this.parseFunctionBody(node, true);
+    this.inGenerator = oldInGen;
+    return this.finishNode(node, "ArrowFunctionExpression");
+  };
 
-  if (isExpression) {
-    node.body = this.parseMaybeAssign();
-    node.expression = true;
-  } else {
-    // Start a new scope with regard to labels and the `inFunction`
-    // flag (restore them to their old value afterwards).
-    var oldInFunc = this.inFunction,
+  // Parse function body and check parameters.
+  pp.parseFunctionBody = function (node, isArrowFunction) {
+    var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;
+
+    if (isExpression) {
+      node.body = this.parseMaybeAssign();
+      node.expression = true;
+    }
+    else {
+      // Start a new scope with regard to labels and the `inFunction`
+      // flag (restore them to their old value afterwards).
+      var oldInFunc = this.inFunction,
         oldLabels = this.labels;
-    this.inFunction = true;this.labels = [];
-    node.body = this.parseBlock(true);
-    node.expression = false;
-    this.inFunction = oldInFunc;this.labels = oldLabels;
-  }
-
-  // If this is a strict mode function, verify that argument names
-  // are not repeated, and it does not try to bind the words `eval`
-  // or `arguments`.
-  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
-    var oldStrict = this.strict;
-    this.strict = true;
-    if (node.id) this.checkLVal(node.id, true);
-    this.checkParams(node);
-    this.strict = oldStrict;
-  } else if (isArrowFunction) {
-    this.checkParams(node);
-  }
-};
-
-// Checks function params for various disallowed patterns such as using "eval"
-// or "arguments" and duplicate parameters.
+      this.inFunction = true;this.labels = [];
+      node.body = this.parseBlock(true);
+      node.expression = false;
+      this.inFunction = oldInFunc;this.labels = oldLabels;
+    }
 
-pp.checkParams = function (node) {
-  var nameHash = {};
-  for (var i = 0; i < node.params.length; i++) {
-    this.checkLVal(node.params[i], true, nameHash);
-  }
-};
+    // If this is a strict mode function, verify that argument names
+    // are not repeated, and it does not try to bind the words `eval`
+    // or `arguments`.
+    if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
+      var oldStrict = this.strict;
+      this.strict = true;
+      if (node.id) {
+        this.checkLVal(node.id, true);
+      }
+      this.checkParams(node);
+      this.strict = oldStrict;
+    }
+    else if (isArrowFunction) {
+      this.checkParams(node);
+    }
+  };
 
-// Parses a comma-separated list of expressions, and returns them as
-// an array. `close` is the token type that ends the list, and
-// `allowEmpty` can be turned on to allow subsequent commas with
-// nothing in between them to be parsed as `null` (which is needed
-// for array literals).
+  // Checks function params for various disallowed patterns such as using "eval"
+  // or "arguments" and duplicate parameters.
+  pp.checkParams = function (node) {
+    var nameHash = {};
+    for (var i = 0; i < node.params.length; i++) {
+      this.checkLVal(node.params[i], true, nameHash);
+    }
+  };
 
-pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
-  var elts = [],
+  // Parses a comma-separated list of expressions, and returns them as
+  // an array. `close` is the token type that ends the list, and
+  // `allowEmpty` can be turned on to allow subsequent commas with
+  // nothing in between them to be parsed as `null` (which is needed
+  // for array literals).
+  pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
+    var elts = [],
       first = true;
-  while (!this.eat(close)) {
-    if (!first) {
-      this.expect(_tokentype.types.comma);
-      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
-        refDestructuringErrors.trailingComma = this.lastTokStart;
+    while (!this.eat(close)) {
+      if (!first) {
+        this.expect(_tokentype.types.comma);
+        if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
+          refDestructuringErrors.trailingComma = this.lastTokStart;
+        }
+        if (allowTrailingComma && this.afterTrailingComma(close)) {
+          break;
+        }
+      }
+      else {
+        first = false;
       }
-      if (allowTrailingComma && this.afterTrailingComma(close)) break;
-    } else first = false;
-
-    var elt = undefined;
-    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
-    elts.push(elt);
-  }
-  return elts;
-};
-
-// Parse the next token as an identifier. If `liberal` is true (used
-// when parsing properties), it will also convert keywords into
-// identifiers.
 
-pp.parseIdent = function (liberal) {
-  var node = this.startNode();
-  if (liberal && this.options.allowReserved == "never") liberal = false;
-  if (this.type === _tokentype.types.name) {
-    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
-    if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
-    node.name = this.value;
-  } else if (liberal && this.type.keyword) {
-    node.name = this.type.keyword;
-  } else {
-    this.unexpected();
-  }
-  this.next();
-  return this.finishNode(node, "Identifier");
-};
+      var elt = undefined;
+      if (allowEmpty && this.type === _tokentype.types.comma) {
+        elt = null;
+      }
+      else if (this.type === _tokentype.types.ellipsis) {
+        elt = this.parseSpread(refDestructuringErrors);
+      }
+      else {
+        elt = this.parseMaybeAssign(false, refDestructuringErrors);
+      }
+      elts.push(elt);
+    }
+    return elts;
+  };
 
-// Parses yield expression inside generator.
+  // Parse the next token as an identifier. If `liberal` is true (used
+  // when parsing properties), it will also convert keywords into
+  // identifiers.
+  pp.parseIdent = function (liberal) {
+    var node = this.startNode();
+    if (liberal && this.options.allowReserved == "never") {
+      liberal = false;
+    }
+    if (this.type === _tokentype.types.name) {
+      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) {
+        this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
+      }
+      if (!liberal && this.inGenerator && this.value === "yield") {
+        this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
+      }
+      node.name = this.value;
+    }
+    else if (liberal && this.type.keyword) {
+      node.name = this.type.keyword;
+    }
+    else {
+      this.unexpected();
+    }
+    this.next();
+    return this.finishNode(node, "Identifier");
+  };
 
-pp.parseYield = function () {
-  var node = this.startNode();
-  this.next();
-  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
-    node.delegate = false;
-    node.argument = null;
-  } else {
-    node.delegate = this.eat(_tokentype.types.star);
-    node.argument = this.parseMaybeAssign();
-  }
-  return this.finishNode(node, "YieldExpression");
-};
+  // Parses yield expression inside generator.
+  pp.parseYield = function () {
+    var node = this.startNode();
+    this.next();
+    if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
+      node.delegate = false;
+      node.argument = null;
+    }
+    else {
+      node.delegate = this.eat(_tokentype.types.star);
+      node.argument = this.parseMaybeAssign();
+    }
+    return this.finishNode(node, "YieldExpression");
+  };
 
 },{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){
-// Reserved word lists for various dialects of the language
-
-"use strict";
+  // Reserved word lists for various dialects of the language.
+  "use strict";
 
-exports.__esModule = true;
-exports.isIdentifierStart = isIdentifierStart;
-exports.isIdentifierChar = isIdentifierChar;
-var reservedWords = {
-  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
-  5: "class enum extends super const export import",
-  6: "enum",
-  7: "enum",
-  strict: "implements interface let package private protected public static yield",
-  strictBind: "eval arguments"
-};
-
-exports.reservedWords = reservedWords;
-// And the keywords
-
-var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
-
-var keywords = {
-  5: ecma5AndLessKeywords,
-  6: ecma5AndLessKeywords + " const class extends export import super"
-};
-
-exports.keywords = keywords;
-// ## Character categories
-
-// Big ugly regular expressions that match characters in the
-// whitespace, identifier, and identifier-start categories. These
-// are only applied when a character is found to actually have a
-// code point above 128.
-// Generated by `bin/generate-identifier-regex.js`.
-
-var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
-var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
-
-var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
-var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
-
-nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
-
-// These are a run-length and offset encoded representation of the
-// >0xffff code points that are a valid part of identifiers. The
-// offset starts at 0x10000, and each pair of numbers represents an
-// offset to the next range, and then a size of the range. They were
-// generated by bin/generate-identifier-regex.js
-var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 287, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 1288, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
-var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 168, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 3617, 6, 792618, 239];
-
-// This has a complexity linear to the value of the code. The
-// assumption is that looking up astral identifier characters is
-// rare.
-function isInAstralSet(code, set) {
-  var pos = 0x10000;
-  for (var i = 0; i < set.length; i += 2) {
-    pos += set[i];
-    if (pos > code) return false;
-    pos += set[i + 1];
-    if (pos >= code) return true;
-  }
-}
-
-// Test whether a given character code starts an identifier.
-
-function isIdentifierStart(code, astral) {
-  if (code < 65) return code === 36;
-  if (code < 91) return true;
-  if (code < 97) return code === 95;
-  if (code < 123) return true;
-  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
-  if (astral === false) return false;
-  return isInAstralSet(code, astralIdentifierStartCodes);
-}
-
-// Test whether a given character is part of an identifier.
-
-function isIdentifierChar(code, astral) {
-  if (code < 48) return code === 36;
-  if (code < 58) return true;
-  if (code < 65) return false;
-  if (code < 91) return true;
-  if (code < 97) return code === 95;
-  if (code < 123) return true;
-  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
-  if (astral === false) return false;
-  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
-}
-
-},{}],3:[function(_dereq_,module,exports){
-// Acorn is a tiny, fast JavaScript parser written in JavaScript.
-//
-// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
-// various contributors and released under an MIT license.
-//
-// Git repositories for Acorn are available at
-//
-//     http://marijnhaverbeke.nl/git/acorn
-//     https://github.com/ternjs/acorn.git
-//
-// Please use the [github bug tracker][ghbt] to report issues.
-//
-// [ghbt]: https://github.com/ternjs/acorn/issues
-//
-// This file defines the main parser interface. The library also comes
-// with a [error-tolerant parser][dammit] and an
-// [abstract syntax tree walker][walk], defined in other files.
-//
-// [dammit]: acorn_loose.js
-// [walk]: util/walk.js
+  exports.__esModule = true;
+  exports.isIdentifierStart = isIdentifierStart;
+  exports.isIdentifierChar = isIdentifierChar;
+  var reservedWords = {
+    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
+    5: "class enum extends super const export import",
+    6: "enum",
+    7: "enum",
+    strict: "implements interface let package private protected public static yield",
+    strictBind: "eval arguments"
+  };
 
-"use strict";
+  exports.reservedWords = reservedWords;
+  // And the keywords.
+  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
+
+  var keywords = {
+    5: ecma5AndLessKeywords,
+    6: ecma5AndLessKeywords + " const class extends export import super"
+  };
 
-exports.__esModule = true;
-exports.parse = parse;
-exports.parseExpressionAt = parseExpressionAt;
-exports.tokenizer = tokenizer;
+  exports.keywords = keywords;
+  // ## Character categories
+  // Big ugly regular expressions that match characters in the
+  // whitespace, identifier, and identifier-start categories. These
+  // are only applied when a character is found to actually have a
+  // code point above 128.
+  // Generated by `bin/generate-identifier-regex.js`.
+  var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
+  var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
+
+  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
+  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
+
+  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
+
+  // These are a run-length and offset encoded representation of the
+  // >0xffff code points that are a valid part of identifiers. The
+  // offset starts at 0x10000, and each pair of numbers represents an
+  // offset to the next range, and then a size of the range. They were
+  // generated by bin/generate-identifier-regex.js.
+  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 287, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 1288, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
+  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 168, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 3617, 6, 792618, 239];
+
+  // This has a complexity linear to the value of the code. The
+  // assumption is that looking up astral identifier characters is
+  // rare.
+  function isInAstralSet(code, set) {
+    var pos = 0x10000;
+    for (var i = 0; i < set.length; i += 2) {
+      pos += set[i];
+      if (pos > code) {
+        return false;
+      }
+      pos += set[i + 1];
+      if (pos >= code) {
+        return true;
+      }
+    }
+  }
 
-var _state = _dereq_("./state");
+  // Test whether a given character code starts an identifier.
+  function isIdentifierStart(code, astral) {
+    if (code < 65) {
+      return code === 36;
+    }
+    if (code < 91) {
+      return true;
+    }
+    if (code < 97) {
+      return code === 95;
+    }
+    if (code < 123) {
+      return true;
+    }
+    if (code <= 0xffff) {
+      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
+    }
+    if (astral === false) {
+      return false;
+    }
+    return isInAstralSet(code, astralIdentifierStartCodes);
+  }
 
-_dereq_("./parseutil");
+  // Test whether a given character is part of an identifier.
+  function isIdentifierChar(code, astral) {
+    if (code < 48) {
+      return code === 36;
+    }
+    if (code < 58) {
+      return true;
+    }
+    if (code < 65) {
+      return false;
+    }
+    if (code < 91) {
+      return true;
+    }
+    if (code < 97) {
+      return code === 95;
+    }
+    if (code < 123) {
+      return true;
+    }
+    if (code <= 0xffff) {
+      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
+    }
+    if (astral === false) {
+      return false;
+    }
+    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
+  }
 
-_dereq_("./statement");
+},{}],3:[function(_dereq_,module,exports){
+  // Acorn is a tiny, fast JavaScript parser written in JavaScript.
+  //
+  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
+  // various contributors and released under an MIT license.
+  //
+  // Git repositories for Acorn are available at
+  //
+  //     http://marijnhaverbeke.nl/git/acorn
+  //     https://github.com/ternjs/acorn.git
+  //
+  // Please use the [github bug tracker][ghbt] to report issues.
+  //
+  // [ghbt]: https://github.com/ternjs/acorn/issues
+  //
+  // This file defines the main parser interface. The library also comes
+  // with a [error-tolerant parser][dammit] and an
+  // [abstract syntax tree walker][walk], defined in other files.
+  //
+  // [dammit]: acorn_loose.js
+  // [walk]: util/walk.js.
+  "use strict";
 
-_dereq_("./lval");
+  exports.__esModule = true;
+  exports.parse = parse;
+  exports.parseExpressionAt = parseExpressionAt;
+  exports.tokenizer = tokenizer;
 
-_dereq_("./expression");
+  var _state = _dereq_("./state");
 
-_dereq_("./location");
+  _dereq_("./parseutil");
 
-exports.Parser = _state.Parser;
-exports.plugins = _state.plugins;
+  _dereq_("./statement");
 
-var _options = _dereq_("./options");
+  _dereq_("./lval");
 
-exports.defaultOptions = _options.defaultOptions;
+  _dereq_("./expression");
 
-var _locutil = _dereq_("./locutil");
+  _dereq_("./location");
 
-exports.Position = _locutil.Position;
-exports.SourceLocation = _locutil.SourceLocation;
-exports.getLineInfo = _locutil.getLineInfo;
+  exports.Parser = _state.Parser;
+  exports.plugins = _state.plugins;
 
-var _node = _dereq_("./node");
+  var _options = _dereq_("./options");
 
-exports.Node = _node.Node;
+  exports.defaultOptions = _options.defaultOptions;
 
-var _tokentype = _dereq_("./tokentype");
+  var _locutil = _dereq_("./locutil");
 
-exports.TokenType = _tokentype.TokenType;
-exports.tokTypes = _tokentype.types;
+  exports.Position = _locutil.Position;
+  exports.SourceLocation = _locutil.SourceLocation;
+  exports.getLineInfo = _locutil.getLineInfo;
 
-var _tokencontext = _dereq_("./tokencontext");
+  var _node = _dereq_("./node");
 
-exports.TokContext = _tokencontext.TokContext;
-exports.tokContexts = _tokencontext.types;
+  exports.Node = _node.Node;
 
-var _identifier = _dereq_("./identifier");
+  var _tokentype = _dereq_("./tokentype");
 
-exports.isIdentifierChar = _identifier.isIdentifierChar;
-exports.isIdentifierStart = _identifier.isIdentifierStart;
+  exports.TokenType = _tokentype.TokenType;
+  exports.tokTypes = _tokentype.types;
 
-var _tokenize = _dereq_("./tokenize");
+  var _tokencontext = _dereq_("./tokencontext");
 
-exports.Token = _tokenize.Token;
+  exports.TokContext = _tokencontext.TokContext;
+  exports.tokContexts = _tokencontext.types;
 
-var _whitespace = _dereq_("./whitespace");
+  var _identifier = _dereq_("./identifier");
 
-exports.isNewLine = _whitespace.isNewLine;
-exports.lineBreak = _whitespace.lineBreak;
-exports.lineBreakG = _whitespace.lineBreakG;
-var version = "3.0.4";
+  exports.isIdentifierChar = _identifier.isIdentifierChar;
+  exports.isIdentifierStart = _identifier.isIdentifierStart;
 
-exports.version = version;
-// The main exported interface (under `self.acorn` when in the
-// browser) is a `parse` function that takes a code string and
-// returns an abstract syntax tree as specified by [Mozilla parser
-// API][api].
-//
-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
+  var _tokenize = _dereq_("./tokenize");
 
-function parse(input, options) {
-  return new _state.Parser(options, input).parse();
-}
+  exports.Token = _tokenize.Token;
 
-// This function tries to parse a single expression at a given
-// offset in a string. Useful for parsing mixed-language formats
-// that embed JavaScript expressions.
-
-function parseExpressionAt(input, pos, options) {
-  var p = new _state.Parser(options, input, pos);
-  p.nextToken();
-  return p.parseExpression();
-}
+  var _whitespace = _dereq_("./whitespace");
 
-// Acorn is organized as a tokenizer and a recursive-descent parser.
-// The `tokenizer` export provides an interface to the tokenizer.
+  exports.isNewLine = _whitespace.isNewLine;
+  exports.lineBreak = _whitespace.lineBreak;
+  exports.lineBreakG = _whitespace.lineBreakG;
+  var version = "3.0.4";
 
-function tokenizer(input, options) {
-  return new _state.Parser(options, input);
-}
+  exports.version = version;
+  // The main exported interface (under `self.acorn` when in the
+  // browser) is a `parse` function that takes a code string and
+  // returns an abstract syntax tree as specified by [Mozilla parser
+  // API][api].
+  //
+  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
+  function parse(input, options) {
+    return new _state.Parser(options, input).parse();
+  }
+
+  // This function tries to parse a single expression at a given
+  // offset in a string. Useful for parsing mixed-language formats
+  // that embed JavaScript expressions.
+  function parseExpressionAt(input, pos, options) {
+    var p = new _state.Parser(options, input, pos);
+    p.nextToken();
+    return p.parseExpression();
+  }
+
+  // Acorn is organized as a tokenizer and a recursive-descent parser.
+  // The `tokenizer` export provides an interface to the tokenizer.
+  function tokenizer(input, options) {
+    return new _state.Parser(options, input);
+  }
 
 },{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
-"use strict";
+  "use strict";
 
-var _state = _dereq_("./state");
+  var _state = _dereq_("./state");
 
-var _locutil = _dereq_("./locutil");
+  var _locutil = _dereq_("./locutil");
 
-var pp = _state.Parser.prototype;
+  var pp = _state.Parser.prototype;
 
-// This function is used to raise exceptions on parse errors. It
-// takes an offset integer (into the current `input`) to indicate
-// the location of the error, attaches the position to the end
-// of the error message, and then raises a `SyntaxError` with that
-// message.
-
-pp.raise = function (pos, message) {
-  var loc = _locutil.getLineInfo(this.input, pos);
-  message += " (" + loc.line + ":" + loc.column + ")";
-  var err = new SyntaxError(message);
-  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
-  throw err;
-};
+  // This function is used to raise exceptions on parse errors. It
+  // takes an offset integer (into the current `input`) to indicate
+  // the location of the error, attaches the position to the end
+  // of the error message, and then raises a `SyntaxError` with that
+  // message.
+  pp.raise = function (pos, message) {
+    var loc = _locutil.getLineInfo(this.input, pos);
+    message += " (" + loc.line + ":" + loc.column + ")";
+    var err = new SyntaxError(message);
+    err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
+    throw err;
+  };
 
 pp.raiseRecoverable = pp.raise;
 
@@ -929,157 +1096,165 @@
 };
 
 },{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
-"use strict";
+  "use strict";
 
-exports.__esModule = true;
-exports.getLineInfo = getLineInfo;
+  exports.__esModule = true;
+  exports.getLineInfo = getLineInfo;
 
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-var _whitespace = _dereq_("./whitespace");
+  var _whitespace = _dereq_("./whitespace");
 
-// These are used when `options.locations` is on, for the
-// `startLoc` and `endLoc` properties.
+  // These are used when `options.locations` is on, for the
+  // `startLoc` and `endLoc` properties.
+  var Position = (function () {
+    function Position(line, col) {
+      _classCallCheck(this, Position);
 
-var Position = (function () {
-  function Position(line, col) {
-    _classCallCheck(this, Position);
+      this.line = line;
+      this.column = col;
+    }
 
-    this.line = line;
-    this.column = col;
-  }
+    Position.prototype.offset = function offset(n) {
+      return new Position(this.line, this.column + n);
+    };
 
-  Position.prototype.offset = function offset(n) {
-    return new Position(this.line, this.column + n);
-  };
+    return Position;
+  })();
 
-  return Position;
-})();
+  exports.Position = Position;
 
-exports.Position = Position;
+  var SourceLocation = function SourceLocation(p, start, end) {
+    _classCallCheck(this, SourceLocation);
 
-var SourceLocation = function SourceLocation(p, start, end) {
-  _classCallCheck(this, SourceLocation);
+    this.start = start;
+    this.end = end;
+    if (p.sourceFile !== null) {
+      this.source = p.sourceFile;
+    }
+  };
 
-  this.start = start;
-  this.end = end;
-  if (p.sourceFile !== null) this.source = p.sourceFile;
-}
+  exports.SourceLocation = SourceLocation;
 
-// The `getLineInfo` function is mostly useful when the
-// `locations` option is off (for performance reasons) and you
-// want to find the line/column position for a given character
-// offset. `input` should be the code string that the offset refers
-// into.
-
-;
-
-exports.SourceLocation = SourceLocation;
-
-function getLineInfo(input, offset) {
-  for (var line = 1, cur = 0;;) {
-    _whitespace.lineBreakG.lastIndex = cur;
-    var match = _whitespace.lineBreakG.exec(input);
-    if (match && match.index < offset) {
-      ++line;
-      cur = match.index + match[0].length;
-    } else {
-      return new Position(line, offset - cur);
+  function getLineInfo(input, offset) {
+    for (var line = 1, cur = 0;;) {
+      _whitespace.lineBreakG.lastIndex = cur;
+      var match = _whitespace.lineBreakG.exec(input);
+      if (match && match.index < offset) {
+        ++line;
+        cur = match.index + match[0].length;
+      }
+      else {
+        return new Position(line, offset - cur);
+      }
     }
   }
-}
 
 },{"./whitespace":16}],6:[function(_dereq_,module,exports){
-"use strict";
-
-var _tokentype = _dereq_("./tokentype");
+  "use strict";
 
-var _state = _dereq_("./state");
+  var _tokentype = _dereq_("./tokentype");
 
-var _util = _dereq_("./util");
+  var _state = _dereq_("./state");
 
-var pp = _state.Parser.prototype;
+  var _util = _dereq_("./util");
 
-// Convert existing expression atom to assignable pattern
-// if possible.
+  var pp = _state.Parser.prototype;
 
-pp.toAssignable = function (node, isBinding) {
-  if (this.options.ecmaVersion >= 6 && node) {
-    switch (node.type) {
-      case "Identifier":
-      case "ObjectPattern":
-      case "ArrayPattern":
-        break;
+  // Convert existing expression atom to assignable pattern
+  // if possible.
+  pp.toAssignable = function (node, isBinding) {
+    if (this.options.ecmaVersion >= 6 && node) {
+      switch (node.type) {
+        case "Identifier":
+        case "ObjectPattern":
+        case "ArrayPattern":
+          break;
 
-      case "ObjectExpression":
-        node.type = "ObjectPattern";
-        for (var i = 0; i < node.properties.length; i++) {
-          var prop = node.properties[i];
-          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
-          this.toAssignable(prop.value, isBinding);
-        }
-        break;
+        case "ObjectExpression":
+          node.type = "ObjectPattern";
+          for (var i = 0; i < node.properties.length; i++) {
+            var prop = node.properties[i];
+            if (prop.kind !== "init") {
+              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
+            }
+            this.toAssignable(prop.value, isBinding);
+          }
+          break;
 
-      case "ArrayExpression":
-        node.type = "ArrayPattern";
-        this.toAssignableList(node.elements, isBinding);
-        break;
+        case "ArrayExpression":
+          node.type = "ArrayPattern";
+          this.toAssignableList(node.elements, isBinding);
+          break;
 
-      case "AssignmentExpression":
-        if (node.operator === "=") {
-          node.type = "AssignmentPattern";
-          delete node.operator;
-          // falls through to AssignmentPattern
-        } else {
+        case "AssignmentExpression":
+          if (node.operator === "=") {
+            node.type = "AssignmentPattern";
+            delete node.operator;
+            // Falls through to AssignmentPattern.
+          }
+          else {
             this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
             break;
           }
 
-      case "AssignmentPattern":
-        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
-        break;
+        case "AssignmentPattern":
+          if (node.right.type === "YieldExpression") {
+            this.raise(node.right.start, "Yield expression cannot be a default value");
+          }
+          break;
 
-      case "ParenthesizedExpression":
-        node.expression = this.toAssignable(node.expression, isBinding);
-        break;
+        case "ParenthesizedExpression":
+          node.expression = this.toAssignable(node.expression, isBinding);
+          break;
 
-      case "MemberExpression":
-        if (!isBinding) break;
+        case "MemberExpression":
+          if (!isBinding) {
+            break;
+          }
 
-      default:
-        this.raise(node.start, "Assigning to rvalue");
+        default:
+          this.raise(node.start, "Assigning to rvalue");
+      }
     }
-  }
-  return node;
-};
+    return node;
+  };
 
 // Convert list of expression atoms to binding list.
-
 pp.toAssignableList = function (exprList, isBinding) {
   var end = exprList.length;
   if (end) {
     var last = exprList[end - 1];
     if (last && last.type == "RestElement") {
       --end;
-    } else if (last && last.type == "SpreadElement") {
+    }
+    else if (last && last.type == "SpreadElement") {
       last.type = "RestElement";
       var arg = last.argument;
       this.toAssignable(arg, isBinding);
-      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
+      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
+        this.unexpected(arg.start);
+      }
       --end;
     }
 
-    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
+    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") {
+      this.unexpected(last.argument.start);
+    }
   }
   for (var i = 0; i < end; i++) {
     var elt = exprList[i];
-    if (elt) this.toAssignable(elt, isBinding);
+    if (elt) {
+      this.toAssignable(elt, isBinding);
+    }
   }
   return exprList;
 };
 
 // Parses spread element.
-
 pp.parseSpread = function (refDestructuringErrors) {
   var node = this.startNode();
   this.next();
@@ -1091,16 +1266,22 @@
   var node = this.startNode();
   this.next();
 
-  // RestElement inside of a function parameter must be an identifier
-  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();
+  // RestElement inside of a function parameter must be an identifier.
+  if (allowNonIdent) {
+    node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();
+  }
+  else {
+    node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();
+  }
 
   return this.finishNode(node, "RestElement");
 };
 
 // Parses lvalue (assignable) atom.
-
 pp.parseBindingAtom = function () {
-  if (this.options.ecmaVersion < 6) return this.parseIdent();
+  if (this.options.ecmaVersion < 6) {
+    return this.parseIdent();
+  }
   switch (this.type) {
     case _tokentype.types.name:
       return this.parseIdent();
@@ -1123,18 +1304,26 @@
   var elts = [],
       first = true;
   while (!this.eat(close)) {
-    if (first) first = false;else this.expect(_tokentype.types.comma);
+    if (first) {
+      first = false;
+    }
+    else {
+      this.expect(_tokentype.types.comma);
+    }
     if (allowEmpty && this.type === _tokentype.types.comma) {
       elts.push(null);
-    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
+    }
+    else if (allowTrailingComma && this.afterTrailingComma(close)) {
       break;
-    } else if (this.type === _tokentype.types.ellipsis) {
+    }
+    else if (this.type === _tokentype.types.ellipsis) {
       var rest = this.parseRest(allowNonIdent);
       this.parseBindingListItem(rest);
       elts.push(rest);
       this.expect(close);
       break;
-    } else {
+    }
+    else {
       var elem = this.parseMaybeDefault(this.start, this.startLoc);
       this.parseBindingListItem(elem);
       elts.push(elem);
@@ -1148,10 +1337,11 @@
 };
 
 // Parses assignment pattern around given atom if possible.
-
 pp.parseMaybeDefault = function (startPos, startLoc, left) {
   left = left || this.parseBindingAtom();
-  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
+  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) {
+    return left;
+  }
   var node = this.startNodeAt(startPos, startLoc);
   node.left = left;
   node.right = this.parseMaybeAssign();
@@ -1160,30 +1350,38 @@
 
 // Verify that a node is an lval — something that can be assigned
 // to.
-
 pp.checkLVal = function (expr, isBinding, checkClashes) {
   switch (expr.type) {
     case "Identifier":
-      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
+      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
+        this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
+      }
       if (checkClashes) {
-        if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
+        if (_util.has(checkClashes, expr.name)) {
+          this.raiseRecoverable(expr.start, "Argument name clash");
+        }
         checkClashes[expr.name] = true;
       }
       break;
 
     case "MemberExpression":
-      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
+      if (isBinding) {
+        this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
+      }
       break;
 
     case "ObjectPattern":
       for (var i = 0; i < expr.properties.length; i++) {
         this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
-      }break;
+      }
+      break;
 
     case "ArrayPattern":
       for (var i = 0; i < expr.elements.length; i++) {
         var elem = expr.elements[i];
-        if (elem) this.checkLVal(elem, isBinding, checkClashes);
+        if (elem) {
+          this.checkLVal(elem, isBinding, checkClashes);
+        }
       }
       break;
 
@@ -1205,49 +1403,57 @@
 };
 
 },{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
-"use strict";
-
-exports.__esModule = true;
+  "use strict";
 
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+  exports.__esModule = true;
 
-var _state = _dereq_("./state");
-
-var _locutil = _dereq_("./locutil");
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-var Node = function Node(parser, pos, loc) {
-  _classCallCheck(this, Node);
+  var _state = _dereq_("./state");
 
-  this.type = "";
-  this.start = pos;
-  this.end = 0;
-  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
-  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
-  if (parser.options.ranges) this.range = [pos, 0];
-}
+  var _locutil = _dereq_("./locutil");
 
-// Start an AST node, attaching a start offset.
+  var Node = function Node(parser, pos, loc) {
+    _classCallCheck(this, Node);
 
-;
+    this.type = "";
+    this.start = pos;
+    this.end = 0;
+    if (parser.options.locations) {
+      this.loc = new _locutil.SourceLocation(parser, loc);
+    }
+    if (parser.options.directSourceFile) {
+      this.sourceFile = parser.options.directSourceFile;
+    }
+    if (parser.options.ranges) {
+      this.range = [pos, 0];
+    }
+  };
 
-exports.Node = Node;
-var pp = _state.Parser.prototype;
+  exports.Node = Node;
+  var pp = _state.Parser.prototype;
 
-pp.startNode = function () {
-  return new Node(this, this.start, this.startLoc);
-};
+  pp.startNode = function () {
+    return new Node(this, this.start, this.startLoc);
+  };
 
 pp.startNodeAt = function (pos, loc) {
   return new Node(this, pos, loc);
 };
 
 // Finish an AST node, adding `type` and `end` properties.
-
 function finishNodeAt(node, type, pos, loc) {
   node.type = type;
   node.end = pos;
-  if (this.options.locations) node.loc.end = loc;
-  if (this.options.ranges) node.range[1] = pos;
+  if (this.options.locations) {
+    node.loc.end = loc;
+  }
+  if (this.options.ranges) {
+    node.range[1] = pos;
+  }
   return node;
 }
 
@@ -1255,213 +1461,219 @@
   return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
 };
 
-// Finish node at given position
-
+// Finish node at given position.
 pp.finishNodeAt = function (node, type, pos, loc) {
   return finishNodeAt.call(this, node, type, pos, loc);
 };
 
 },{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
-"use strict";
-
-exports.__esModule = true;
-exports.getOptions = getOptions;
+  "use strict";
 
-var _util = _dereq_("./util");
+  exports.__esModule = true;
+  exports.getOptions = getOptions;
 
-var _locutil = _dereq_("./locutil");
+  var _util = _dereq_("./util");
 
-// A second optional argument can be given to further configure
-// the parser process. These options are recognized:
-
-var defaultOptions = {
-  // `ecmaVersion` indicates the ECMAScript version to parse. Must
-  // be either 3, or 5, or 6. This influences support for strict
-  // mode, the set of reserved words, support for getters and
-  // setters and other features. The default is 6.
-  ecmaVersion: 6,
-  // Source type ("script" or "module") for different semantics
-  sourceType: "script",
-  // `onInsertedSemicolon` can be a callback that will be called
-  // when a semicolon is automatically inserted. It will be passed
-  // th position of the comma as an offset, and if `locations` is
-  // enabled, it is given the location as a `{line, column}` object
-  // as second argument.
-  onInsertedSemicolon: null,
-  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
-  // trailing commas.
-  onTrailingComma: null,
-  // By default, reserved words are only enforced if ecmaVersion >= 5.
-  // Set `allowReserved` to a boolean value to explicitly turn this on
-  // an off. When this option has the value "never", reserved words
-  // and keywords can also not be used as property names.
-  allowReserved: null,
-  // When enabled, a return at the top level is not considered an
-  // error.
-  allowReturnOutsideFunction: false,
-  // When enabled, import/export statements are not constrained to
-  // appearing at the top of the program.
-  allowImportExportEverywhere: false,
-  // When enabled, hashbang directive in the beginning of file
-  // is allowed and treated as a line comment.
-  allowHashBang: false,
-  // When `locations` is on, `loc` properties holding objects with
-  // `start` and `end` properties in `{line, column}` form (with
-  // line being 1-based and column 0-based) will be attached to the
-  // nodes.
-  locations: false,
-  // A function can be passed as `onToken` option, which will
-  // cause Acorn to call that function with object in the same
-  // format as tokens returned from `tokenizer().getToken()`. Note
-  // that you are not allowed to call the parser from the
-  // callback—that will corrupt its internal state.
-  onToken: null,
-  // A function can be passed as `onComment` option, which will
-  // cause Acorn to call that function with `(block, text, start,
-  // end)` parameters whenever a comment is skipped. `block` is a
-  // boolean indicating whether this is a block (`/* */`) comment,
-  // `text` is the content of the comment, and `start` and `end` are
-  // character offsets that denote the start and end of the comment.
-  // When the `locations` option is on, two more parameters are
-  // passed, the full `{line, column}` locations of the start and
-  // end of the comments. Note that you are not allowed to call the
-  // parser from the callback—that will corrupt its internal state.
-  onComment: null,
-  // Nodes have their start and end characters offsets recorded in
-  // `start` and `end` properties (directly on the node, rather than
-  // the `loc` object, which holds line/column data. To also add a
-  // [semi-standardized][range] `range` property holding a `[start,
-  // end]` array with the same numbers, set the `ranges` option to
-  // `true`.
-  //
-  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
-  ranges: false,
-  // It is possible to parse multiple files into a single AST by
-  // passing the tree produced by parsing the first file as
-  // `program` option in subsequent parses. This will add the
-  // toplevel forms of the parsed file to the `Program` (top) node
-  // of an existing parse tree.
-  program: null,
-  // When `locations` is on, you can pass this to record the source
-  // file in every node's `loc` object.
-  sourceFile: null,
-  // This value, if given, is stored in every node, whether
-  // `locations` is on or off.
-  directSourceFile: null,
-  // When enabled, parenthesized expressions are represented by
-  // (non-standard) ParenthesizedExpression nodes
-  preserveParens: false,
-  plugins: {}
-};
-
-exports.defaultOptions = defaultOptions;
-// Interpret and default an options object
-
-function getOptions(opts) {
-  var options = {};
-  for (var opt in defaultOptions) {
-    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
-  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
-
-  if (_util.isArray(options.onToken)) {
-    (function () {
-      var tokens = options.onToken;
-      options.onToken = function (token) {
-        return tokens.push(token);
-      };
-    })();
-  }
-  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
+  var _locutil = _dereq_("./locutil");
 
-  return options;
-}
+  // A second optional argument can be given to further configure
+  // the parser process. These options are recognized:
+  var defaultOptions = {
+    // `ecmaVersion` indicates the ECMAScript version to parse. Must
+    // be either 3, or 5, or 6. This influences support for strict
+    // mode, the set of reserved words, support for getters and
+    // setters and other features. The default is 6.
+    ecmaVersion: 6,
+    // Source type ("script" or "module") for different semantics.
+    sourceType: "script",
+    // `onInsertedSemicolon` can be a callback that will be called
+    // when a semicolon is automatically inserted. It will be passed
+    // th position of the comma as an offset, and if `locations` is
+    // enabled, it is given the location as a `{line, column}` object
+    // as second argument.
+    onInsertedSemicolon: null,
+    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
+    // trailing commas.
+    onTrailingComma: null,
+    // By default, reserved words are only enforced if ecmaVersion >= 5.
+    // Set `allowReserved` to a boolean value to explicitly turn this on
+    // an off. When this option has the value "never", reserved words
+    // and keywords can also not be used as property names.
+    allowReserved: null,
+    // When enabled, a return at the top level is not considered an
+    // error.
+    allowReturnOutsideFunction: false,
+    // When enabled, import/export statements are not constrained to
+    // appearing at the top of the program.
+    allowImportExportEverywhere: false,
+    // When enabled, hashbang directive in the beginning of file
+    // is allowed and treated as a line comment.
+    allowHashBang: false,
+    // When `locations` is on, `loc` properties holding objects with
+    // `start` and `end` properties in `{line, column}` form (with
+    // line being 1-based and column 0-based) will be attached to the
+    // nodes.
+    locations: false,
+    // A function can be passed as `onToken` option, which will
+    // cause Acorn to call that function with object in the same
+    // format as tokens returned from `tokenizer().getToken()`. Note
+    // that you are not allowed to call the parser from the
+    // callback—that will corrupt its internal state.
+    onToken: null,
+    // A function can be passed as `onComment` option, which will
+    // cause Acorn to call that function with `(block, text, start,
+    // end)` parameters whenever a comment is skipped. `block` is a
+    // boolean indicating whether this is a block (`/* */`) comment,
+    // `text` is the content of the comment, and `start` and `end` are
+    // character offsets that denote the start and end of the comment.
+    // When the `locations` option is on, two more parameters are
+    // passed, the full `{line, column}` locations of the start and
+    // end of the comments. Note that you are not allowed to call the
+    // parser from the callback—that will corrupt its internal state.
+    onComment: null,
+    // Nodes have their start and end characters offsets recorded in
+    // `start` and `end` properties (directly on the node, rather than
+    // the `loc` object, which holds line/column data. To also add a
+    // [semi-standardized][range] `range` property holding a `[start,
+    // end]` array with the same numbers, set the `ranges` option to
+    // `true`.
+    //
+    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
+    ranges: false,
+    // It is possible to parse multiple files into a single AST by
+    // passing the tree produced by parsing the first file as
+    // `program` option in subsequent parses. This will add the
+    // toplevel forms of the parsed file to the `Program` (top) node
+    // of an existing parse tree.
+    program: null,
+    // When `locations` is on, you can pass this to record the source
+    // file in every node's `loc` object.
+    sourceFile: null,
+    // This value, if given, is stored in every node, whether
+    // `locations` is on or off.
+    directSourceFile: null,
+    // When enabled, parenthesized expressions are represented by
+    // (non-standard) ParenthesizedExpression nodes.
+    preserveParens: false,
+    plugins: {}
+  };
 
-function pushComment(options, array) {
-  return function (block, text, start, end, startLoc, endLoc) {
-    var comment = {
-      type: block ? 'Block' : 'Line',
-      value: text,
-      start: start,
-      end: end
+  exports.defaultOptions = defaultOptions;
+  // Interpret and default an options object.
+  function getOptions(opts) {
+    var options = {};
+    for (var opt in defaultOptions) {
+      options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
+    }if (options.allowReserved == null) {
+      options.allowReserved = options.ecmaVersion < 5;
+    }
+
+    if (_util.isArray(options.onToken)) {
+      (function () {
+        var tokens = options.onToken;
+        options.onToken = function (token) {
+          return tokens.push(token);
+        };
+      })();
+    }
+    if (_util.isArray(options.onComment)) {
+      options.onComment = pushComment(options, options.onComment);
+    }
+
+    return options;
+  }
+
+  function pushComment(options, array) {
+    return function (block, text, start, end, startLoc, endLoc) {
+      var comment = {
+        type: block ? 'Block' : 'Line',
+        value: text,
+        start: start,
+        end: end
+      };
+      if (options.locations) {
+        comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
+      }
+      if (options.ranges) {
+        comment.range = [start, end];
+      }
+      array.push(comment);
     };
-    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
-    if (options.ranges) comment.range = [start, end];
-    array.push(comment);
-  };
-}
+  }
 
 },{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
-"use strict";
-
-var _tokentype = _dereq_("./tokentype");
+  "use strict";
 
-var _state = _dereq_("./state");
+  var _tokentype = _dereq_("./tokentype");
 
-var _whitespace = _dereq_("./whitespace");
+  var _state = _dereq_("./state");
 
-var pp = _state.Parser.prototype;
+  var _whitespace = _dereq_("./whitespace");
 
-// ## Parser utilities
+  var pp = _state.Parser.prototype;
 
-// Test whether a statement node is the string literal `"use strict"`.
-
-pp.isUseStrict = function (stmt) {
-  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
-};
+  // ## Parser utilities
+  // Test whether a statement node is the string literal `"use strict"`.
+  pp.isUseStrict = function (stmt) {
+    return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
+  };
 
 // Predicate that tests whether the next token is of the given
 // type, and if yes, consumes it as a side effect.
-
 pp.eat = function (type) {
   if (this.type === type) {
     this.next();
     return true;
-  } else {
+  }
+  else {
     return false;
   }
 };
 
 // Tests whether parsed token is a contextual keyword.
-
 pp.isContextual = function (name) {
   return this.type === _tokentype.types.name && this.value === name;
 };
 
 // Consumes contextual keyword if possible.
-
 pp.eatContextual = function (name) {
   return this.value === name && this.eat(_tokentype.types.name);
 };
 
 // Asserts that following token is given contextual keyword.
-
 pp.expectContextual = function (name) {
-  if (!this.eatContextual(name)) this.unexpected();
+  if (!this.eatContextual(name)) {
+    this.unexpected();
+  }
 };
 
 // Test whether a semicolon can be inserted at the current position.
-
 pp.canInsertSemicolon = function () {
   return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
 };
 
 pp.insertSemicolon = function () {
   if (this.canInsertSemicolon()) {
-    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
+    if (this.options.onInsertedSemicolon) {
+      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
+    }
     return true;
   }
 };
 
 // Consume a semicolon, or, failing that, see if we are allowed to
 // pretend that there is a semicolon at this position.
-
 pp.semicolon = function () {
-  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
+  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) {
+    this.unexpected();
+  }
 };
 
 pp.afterTrailingComma = function (tokType) {
   if (this.type == tokType) {
-    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
+    if (this.options.onTrailingComma) {
+      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
+    }
     this.next();
     return true;
   }
@@ -1469,207 +1681,229 @@
 
 // Expect a token of a given type. If found, consume it, otherwise,
 // raise an unexpected token error.
-
 pp.expect = function (type) {
   this.eat(type) || this.unexpected();
 };
 
 // Raise an unexpected token error.
-
 pp.unexpected = function (pos) {
   this.raise(pos != null ? pos : this.start, "Unexpected token");
 };
 
 pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
   var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
-  if (!andThrow) return !!pos;
-  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
+  if (!andThrow) {
+    return !!pos;
+  }
+  if (pos) {
+    this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
+  }
 };
 
 pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
   var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
-  if (!andThrow) return !!pos;
-  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
+  if (!andThrow) {
+    return !!pos;
+  }
+  if (pos) {
+    this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
+  }
 };
 
 },{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
-"use strict";
-
-exports.__esModule = true;
-
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
-
-var _identifier = _dereq_("./identifier");
-
-var _tokentype = _dereq_("./tokentype");
+  "use strict";
 
-var _whitespace = _dereq_("./whitespace");
+  exports.__esModule = true;
 
-var _options = _dereq_("./options");
-
-// Registered plugins
-var plugins = {};
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-exports.plugins = plugins;
-function keywordRegexp(words) {
-  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
-}
+  var _identifier = _dereq_("./identifier");
 
-var Parser = (function () {
-  function Parser(options, input, startPos) {
-    _classCallCheck(this, Parser);
-
-    this.options = options = _options.getOptions(options);
-    this.sourceFile = options.sourceFile;
-    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
-    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
-    this.reservedWords = keywordRegexp(reserved);
-    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
-    this.reservedWordsStrict = keywordRegexp(reservedStrict);
-    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
-    this.input = String(input);
-
-    // Used to signal to callers of `readWord1` whether the word
-    // contained any escape sequences. This is needed because words with
-    // escape sequences must not be interpreted as keywords.
-    this.containsEsc = false;
-
-    // Load plugins
-    this.loadPlugins(options.plugins);
-
-    // Set up token state
-
-    // The current position of the tokenizer in the input.
-    if (startPos) {
-      this.pos = startPos;
-      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
-      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
-    } else {
-      this.pos = this.lineStart = 0;
-      this.curLine = 1;
-    }
-
-    // Properties of the current token:
-    // Its type
-    this.type = _tokentype.types.eof;
-    // For tokens that include more information than their type, the value
-    this.value = null;
-    // Its start and end offset
-    this.start = this.end = this.pos;
-    // And, if locations are used, the {line, column} object
-    // corresponding to those offsets
-    this.startLoc = this.endLoc = this.curPosition();
-
-    // Position information for the previous token
-    this.lastTokEndLoc = this.lastTokStartLoc = null;
-    this.lastTokStart = this.lastTokEnd = this.pos;
-
-    // The context stack is used to superficially track syntactic
-    // context to predict whether a regular expression is allowed in a
-    // given position.
-    this.context = this.initialContext();
-    this.exprAllowed = true;
+  var _tokentype = _dereq_("./tokentype");
 
-    // Figure out if it's a module code.
-    this.strict = this.inModule = options.sourceType === "module";
+  var _whitespace = _dereq_("./whitespace");
 
-    // Used to signify the start of a potential arrow function
-    this.potentialArrowAt = -1;
+  var _options = _dereq_("./options");
 
-    // Flags to track whether we are in a function, a generator.
-    this.inFunction = this.inGenerator = false;
-    // Labels in scope.
-    this.labels = [];
+  // Registered plugins.
+  var plugins = {};
 
-    // If enabled, skip leading hashbang line.
-    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
+  exports.plugins = plugins;
+  function keywordRegexp(words) {
+    return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
   }
 
-  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
+  var Parser = (function () {
+    function Parser(options, input, startPos) {
+      _classCallCheck(this, Parser);
 
-  Parser.prototype.isKeyword = function isKeyword(word) {
-    return this.keywords.test(word);
-  };
+      this.options = options = _options.getOptions(options);
+      this.sourceFile = options.sourceFile;
+      this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
+      var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
+      this.reservedWords = keywordRegexp(reserved);
+      var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
+      this.reservedWordsStrict = keywordRegexp(reservedStrict);
+      this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
+      this.input = String(input);
 
-  Parser.prototype.isReservedWord = function isReservedWord(word) {
-    return this.reservedWords.test(word);
-  };
+      // Used to signal to callers of `readWord1` whether the word
+      // contained any escape sequences. This is needed because words with
+      // escape sequences must not be interpreted as keywords.
+      this.containsEsc = false;
 
-  Parser.prototype.extend = function extend(name, f) {
-    this[name] = f(this[name]);
-  };
+      // Load plugins.
+      this.loadPlugins(options.plugins);
 
-  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
-    for (var _name in pluginConfigs) {
-      var plugin = plugins[_name];
-      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
-      plugin(this, pluginConfigs[_name]);
+      // Set up token state.
+      // The current position of the tokenizer in the input.
+      if (startPos) {
+        this.pos = startPos;
+        this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
+        this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
+      }
+      else {
+        this.pos = this.lineStart = 0;
+        this.curLine = 1;
+      }
+
+      // Properties of the current token:
+      // Its type.
+      this.type = _tokentype.types.eof;
+      // For tokens that include more information than their type, the value.
+      this.value = null;
+      // Its start and end offset.
+      this.start = this.end = this.pos;
+      // And, if locations are used, the {line, column} object
+      // corresponding to those offsets.
+      this.startLoc = this.endLoc = this.curPosition();
+
+      // Position information for the previous token.
+      this.lastTokEndLoc = this.lastTokStartLoc = null;
+      this.lastTokStart = this.lastTokEnd = this.pos;
+
+      // The context stack is used to superficially track syntactic
+      // context to predict whether a regular expression is allowed in a
+      // given position.
+      this.context = this.initialContext();
+      this.exprAllowed = true;
+
+      // Figure out if it's a module code.
+      this.strict = this.inModule = options.sourceType === "module";
+
+      // Used to signify the start of a potential arrow function.
+      this.potentialArrowAt = -1;
+
+      // Flags to track whether we are in a function, a generator.
+      this.inFunction = this.inGenerator = false;
+      // Labels in scope.
+      this.labels = [];
+
+      // If enabled, skip leading hashbang line.
+      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') {
+        this.skipLineComment(2);
+      }
     }
-  };
 
-  Parser.prototype.parse = function parse() {
-    var node = this.options.program || this.startNode();
-    this.nextToken();
-    return this.parseTopLevel(node);
-  };
+    // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them.
+    Parser.prototype.isKeyword = function isKeyword(word) {
+      return this.keywords.test(word);
+    };
 
-  return Parser;
-})();
+    Parser.prototype.isReservedWord = function isReservedWord(word) {
+      return this.reservedWords.test(word);
+    };
 
-exports.Parser = Parser;
+    Parser.prototype.extend = function extend(name, f) {
+      this[name] = f(this[name]);
+    };
 
-},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
-"use strict";
+    Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
+      for (var _name in pluginConfigs) {
+        var plugin = plugins[_name];
+        if (!plugin) {
+          throw new Error("Plugin '" + _name + "' not found");
+        }
+        plugin(this, pluginConfigs[_name]);
+      }
+    };
 
-var _tokentype = _dereq_("./tokentype");
+    Parser.prototype.parse = function parse() {
+      var node = this.options.program || this.startNode();
+      this.nextToken();
+      return this.parseTopLevel(node);
+    };
 
-var _state = _dereq_("./state");
+    return Parser;
+  })();
 
-var _whitespace = _dereq_("./whitespace");
+  exports.Parser = Parser;
 
-var _identifier = _dereq_("./identifier");
+},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
+  "use strict";
 
-var pp = _state.Parser.prototype;
+  var _tokentype = _dereq_("./tokentype");
 
-// ### Statement parsing
+  var _state = _dereq_("./state");
 
-// Parse a program. Initializes the parser, reads any number of
-// statements, and wraps them in a Program node.  Optionally takes a
-// `program` argument.  If present, the statements will be appended
-// to its body instead of creating a new node.
+  var _whitespace = _dereq_("./whitespace");
 
-pp.parseTopLevel = function (node) {
-  var first = true;
-  if (!node.body) node.body = [];
-  while (this.type !== _tokentype.types.eof) {
-    var stmt = this.parseStatement(true, true);
-    node.body.push(stmt);
-    if (first) {
-      if (this.isUseStrict(stmt)) this.setStrict(true);
-      first = false;
+  var _identifier = _dereq_("./identifier");
+
+  var pp = _state.Parser.prototype;
+
+  // ### Statement parsing
+  // Parse a program. Initializes the parser, reads any number of
+  // statements, and wraps them in a Program node.  Optionally takes a
+  // `program` argument.  If present, the statements will be appended
+  // to its body instead of creating a new node.
+  pp.parseTopLevel = function (node) {
+    var first = true;
+    if (!node.body) {
+      node.body = [];
+    }
+    while (this.type !== _tokentype.types.eof) {
+      var stmt = this.parseStatement(true, true);
+      node.body.push(stmt);
+      if (first) {
+        if (this.isUseStrict(stmt)) {
+          this.setStrict(true);
+        }
+        first = false;
+      }
     }
-  }
-  this.next();
-  if (this.options.ecmaVersion >= 6) {
-    node.sourceType = this.options.sourceType;
-  }
-  return this.finishNode(node, "Program");
-};
+    this.next();
+    if (this.options.ecmaVersion >= 6) {
+      node.sourceType = this.options.sourceType;
+    }
+    return this.finishNode(node, "Program");
+  };
 
 var loopLabel = { kind: "loop" },
     switchLabel = { kind: "switch" };
 
 pp.isLet = function () {
-  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
+  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") {
+    return false;
+  }
   _whitespace.skipWhiteSpace.lastIndex = this.pos;
   var skip = _whitespace.skipWhiteSpace.exec(this.input);
   var next = this.pos + skip[0].length,
       nextCh = this.input.charCodeAt(next);
-  if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
-  if (_identifier.isIdentifierStart(nextCh, true)) {
-    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
+  if (nextCh === 91 || nextCh == 123) {
+    // '{' and '['.
+    return true;
+  }  if (_identifier.isIdentifierStart(nextCh, true)) {
+    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {
+
+    }
     var ident = this.input.slice(next, pos);
-    if (!this.isKeyword(ident)) return true;
+    if (!this.isKeyword(ident)) {
+      return true;
+    }
   }
   return false;
 };
@@ -1680,7 +1914,6 @@
 // regular expression literal. This is to handle cases like
 // `if (foo) /blah/.exec(foo)`, where looking at the previous token
 // does not help.
-
 pp.parseStatement = function (declaration, topLevel) {
   var starttype = this.type,
       node = this.startNode(),
@@ -1694,49 +1927,74 @@
   // Most types of statements are recognized by the keyword they
   // start with. Many are trivial to parse, some require a bit of
   // complexity.
-
   switch (starttype) {
     case _tokentype.types._break:case _tokentype.types._continue:
       return this.parseBreakContinueStatement(node, starttype.keyword);
+
     case _tokentype.types._debugger:
       return this.parseDebuggerStatement(node);
+
     case _tokentype.types._do:
       return this.parseDoStatement(node);
+
     case _tokentype.types._for:
       return this.parseForStatement(node);
+
     case _tokentype.types._function:
-      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
+      if (!declaration && this.options.ecmaVersion >= 6) {
+        this.unexpected();
+      }
       return this.parseFunctionStatement(node);
+
     case _tokentype.types._class:
-      if (!declaration) this.unexpected();
+      if (!declaration) {
+        this.unexpected();
+      }
       return this.parseClass(node, true);
+
     case _tokentype.types._if:
       return this.parseIfStatement(node);
+
     case _tokentype.types._return:
       return this.parseReturnStatement(node);
+
     case _tokentype.types._switch:
       return this.parseSwitchStatement(node);
+
     case _tokentype.types._throw:
       return this.parseThrowStatement(node);
+
     case _tokentype.types._try:
       return this.parseTryStatement(node);
+
     case _tokentype.types._const:case _tokentype.types._var:
-      kind = kind || this.value;
-      if (!declaration && kind != "var") this.unexpected();
+        kind = kind || this.value;
+        if (!declaration && kind != "var") {
+          this.unexpected();
+        }
       return this.parseVarStatement(node, kind);
+
     case _tokentype.types._while:
       return this.parseWhileStatement(node);
+
     case _tokentype.types._with:
       return this.parseWithStatement(node);
+
     case _tokentype.types.braceL:
       return this.parseBlock();
+
     case _tokentype.types.semi:
       return this.parseEmptyStatement(node);
+
     case _tokentype.types._export:
     case _tokentype.types._import:
       if (!this.options.allowImportExportEverywhere) {
-        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
-        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
+        if (!topLevel) {
+          this.raise(this.start, "'import' and 'export' may only appear at the top level");
+        }
+        if (!this.inModule) {
+          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
+        }
       }
       return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);
 
@@ -1748,14 +2006,25 @@
     default:
       var maybeName = this.value,
           expr = this.parseExpression();
-      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
+      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) {
+        return this.parseLabeledStatement(node, maybeName, expr);
+      }
+      else {
+        return this.parseExpressionStatement(node, expr);
+      }
   }
 };
 
 pp.parseBreakContinueStatement = function (node, keyword) {
   var isBreak = keyword == "break";
   this.next();
-  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
+  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) {
+    node.label = null;
+  }
+  else if (this.type !== _tokentype.types.name) {
+    this.unexpected();
+  }
+  else {
     node.label = this.parseIdent();
     this.semicolon();
   }
@@ -1765,11 +2034,17 @@
   for (var i = 0; i < this.labels.length; ++i) {
     var lab = this.labels[i];
     if (node.label == null || lab.name === node.label.name) {
-      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
-      if (node.label && isBreak) break;
+      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
+        break;
+      }
+      if (node.label && isBreak) {
+        break;
+      }
     }
   }
-  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
+  if (i === this.labels.length) {
+    this.raise(node.start, "Unsyntactic " + keyword);
+  }
   return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
 };
 
@@ -1786,7 +2061,12 @@
   this.labels.pop();
   this.expect(_tokentype.types._while);
   node.test = this.parseParenExpression();
-  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
+  if (this.options.ecmaVersion >= 6) {
+    this.eat(_tokentype.types.semi);
+  }
+  else {
+    this.semicolon();
+  }
   return this.finishNode(node, "DoWhileStatement");
 };
 
@@ -1797,12 +2077,13 @@
 // whether the next token is `in` or `of`. When there is no init
 // part (semicolon immediately after the opening parenthesis), it
 // is a regular `for` loop.
-
 pp.parseForStatement = function (node) {
   this.next();
   this.labels.push(loopLabel);
   this.expect(_tokentype.types.parenL);
-  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
+  if (this.type === _tokentype.types.semi) {
+    return this.parseFor(node, null);
+  }
   var isLet = this.isLet();
   if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
     var _init = this.startNode(),
@@ -1810,7 +2091,9 @@
     this.next();
     this.parseVar(_init, true, kind);
     this.finishNode(_init, "VariableDeclaration");
-    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
+    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) {
+      return this.parseForIn(node, _init);
+    }
     return this.parseFor(node, _init);
   }
   var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
@@ -1820,7 +2103,8 @@
     this.toAssignable(init);
     this.checkLVal(init);
     return this.parseForIn(node, init);
-  } else {
+  }
+  else {
     this.checkExpressionErrors(refDestructuringErrors, true);
   }
   return this.parseFor(node, init);
@@ -1840,14 +2124,18 @@
 };
 
 pp.parseReturnStatement = function (node) {
-  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
+  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
+    this.raise(this.start, "'return' outside of function");
+  }
   this.next();
 
   // In `return` (and `break`/`continue`), the keywords with
   // optional arguments, we eagerly look for a semicolon or the
   // possibility to insert one.
-
-  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
+  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) {
+    node.argument = null;
+  }
+  else {
     node.argument = this.parseExpression();this.semicolon();
   }
   return this.finishNode(node, "ReturnStatement");
@@ -1863,43 +2151,54 @@
   // Statements under must be grouped (by label) in SwitchCase
   // nodes. `cur` is used to keep the node that we are currently
   // adding statements to.
-
   for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
     if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
       var isCase = this.type === _tokentype.types._case;
-      if (cur) this.finishNode(cur, "SwitchCase");
+      if (cur) {
+        this.finishNode(cur, "SwitchCase");
+      }
       node.cases.push(cur = this.startNode());
       cur.consequent = [];
       this.next();
       if (isCase) {
         cur.test = this.parseExpression();
-      } else {
-        if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
+      }
+      else {
+        if (sawDefault) {
+          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
+        }
         sawDefault = true;
         cur.test = null;
       }
       this.expect(_tokentype.types.colon);
-    } else {
-      if (!cur) this.unexpected();
+    }
+    else {
+      if (!cur) {
+        this.unexpected();
+      }
       cur.consequent.push(this.parseStatement(true));
     }
   }
-  if (cur) this.finishNode(cur, "SwitchCase");
-  this.next(); // Closing brace
+  if (cur) {
+    this.finishNode(cur, "SwitchCase");
+  }
+  // Closing brace.
+  this.next();
   this.labels.pop();
   return this.finishNode(node, "SwitchStatement");
 };
 
 pp.parseThrowStatement = function (node) {
   this.next();
-  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
+  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
+    this.raise(this.lastTokEnd, "Illegal newline after throw");
+  }
   node.argument = this.parseExpression();
   this.semicolon();
   return this.finishNode(node, "ThrowStatement");
 };
 
 // Reused empty array added for node fields that are always empty.
-
 var empty = [];
 
 pp.parseTryStatement = function (node) {
@@ -1917,7 +2216,9 @@
     node.handler = this.finishNode(clause, "CatchClause");
   }
   node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
-  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
+  if (!node.handler && !node.finalizer) {
+    this.raise(node.start, "Missing catch or finally clause");
+  }
   return this.finishNode(node, "TryStatement");
 };
 
@@ -1938,7 +2239,9 @@
 };
 
 pp.parseWithStatement = function (node) {
-  if (this.strict) this.raise(this.start, "'with' in strict mode");
+  if (this.strict) {
+    this.raise(this.start, "'with' in strict mode");
+  }
   this.next();
   node.object = this.parseParenExpression();
   node.body = this.parseStatement(false);
@@ -1952,14 +2255,19 @@
 
 pp.parseLabeledStatement = function (node, maybeName, expr) {
   for (var i = 0; i < this.labels.length; ++i) {
-    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
+    if (this.labels[i].name === maybeName) {
+      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
+    }
   }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
   for (var i = this.labels.length - 1; i >= 0; i--) {
     var label = this.labels[i];
     if (label.statementStart == node.start) {
       label.statementStart = this.start;
       label.kind = kind;
-    } else break;
+    }
+    else {
+      break;
+    }
   }
   this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
   node.body = this.parseStatement(true);
@@ -1977,7 +2285,6 @@
 // Parse a semicolon-enclosed block of statements, handling `"use
 // strict"` declarations when `allowStrict` is true (used for
 // function bodies).
-
 pp.parseBlock = function (allowStrict) {
   var node = this.startNode(),
       first = true,
@@ -1993,14 +2300,15 @@
     }
     first = false;
   }
-  if (oldStrict === false) this.setStrict(false);
+  if (oldStrict === false) {
+    this.setStrict(false);
+  }
   return this.finishNode(node, "BlockStatement");
 };
 
 // Parse a regular `for` loop. The disambiguation code in
 // `parseStatement` will already have parsed the init statement or
 // expression.
-
 pp.parseFor = function (node, init) {
   node.init = init;
   this.expect(_tokentype.types.semi);
@@ -2015,7 +2323,6 @@
 
 // Parse a `for`/`in` and `for`/`of` loop, which are almost
 // same from parser's perspective.
-
 pp.parseForIn = function (node, init) {
   var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
   this.next();
@@ -2028,7 +2335,6 @@
 };
 
 // Parse a list of variable declarations.
-
 pp.parseVar = function (node, isFor, kind) {
   node.declarations = [];
   node.kind = kind;
@@ -2037,15 +2343,20 @@
     this.parseVarId(decl);
     if (this.eat(_tokentype.types.eq)) {
       decl.init = this.parseMaybeAssign(isFor);
-    } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+    }
+    else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
       this.unexpected();
-    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
+    }
+    else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
       this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
-    } else {
+    }
+    else {
       decl.init = null;
     }
     node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
-    if (!this.eat(_tokentype.types.comma)) break;
+    if (!this.eat(_tokentype.types.comma)) {
+      break;
+    }
   }
   return node;
 };
@@ -2057,13 +2368,16 @@
 
 // Parse a function declaration or literal (depending on the
 // `isStatement` parameter).
-
 pp.parseFunction = function (node, isStatement, allowExpressionBody) {
   this.initFunction(node);
-  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
+  if (this.options.ecmaVersion >= 6) {
+    node.generator = this.eat(_tokentype.types.star);
+  }
   var oldInGen = this.inGenerator;
   this.inGenerator = node.generator;
-  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
+  if (isStatement || this.type === _tokentype.types.name) {
+    node.id = this.parseIdent();
+  }
   this.parseFunctionParams(node);
   this.parseFunctionBody(node, allowExpressionBody);
   this.inGenerator = oldInGen;
@@ -2077,7 +2391,6 @@
 
 // Parse a class declaration or literal (depending on the
 // `isStatement` parameter).
-
 pp.parseClass = function (node, isStatement) {
   this.next();
   this.parseClassId(node, isStatement);
@@ -2087,14 +2400,18 @@
   classBody.body = [];
   this.expect(_tokentype.types.braceL);
   while (!this.eat(_tokentype.types.braceR)) {
-    if (this.eat(_tokentype.types.semi)) continue;
+    if (this.eat(_tokentype.types.semi)) {
+      continue;
+    }
     var method = this.startNode();
     var isGenerator = this.eat(_tokentype.types.star);
     var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
     this.parsePropertyName(method);
     method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
     if (method["static"]) {
-      if (isGenerator) this.unexpected();
+      if (isGenerator) {
+        this.unexpected();
+      }
       isGenerator = this.eat(_tokentype.types.star);
       this.parsePropertyName(method);
     }
@@ -2109,9 +2426,15 @@
         key = this.parsePropertyName(method);
       }
       if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
-        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
-        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
-        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
+        if (hadConstructor) {
+          this.raise(key.start, "Duplicate constructor in the same class");
+        }
+        if (isGetSet) {
+          this.raise(key.start, "Constructor can't have get/set modifier");
+        }
+        if (isGenerator) {
+          this.raise(key.start, "Constructor can't be a generator");
+        }
         method.kind = "constructor";
         hadConstructor = true;
       }
@@ -2121,9 +2444,16 @@
       var paramCount = method.kind === "get" ? 0 : 1;
       if (method.value.params.length !== paramCount) {
         var start = method.value.start;
-        if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
+        if (method.kind === "get") {
+          this.raiseRecoverable(start, "getter should have no params");
+        }
+        else {
+          this.raiseRecoverable(start, "setter should have exactly one param");
+        }
+      }
+      if (method.kind === "set" && method.value.params[0].type === "RestElement") {
+        this.raise(method.value.params[0].start, "Setter cannot use rest params");
       }
-      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
     }
   }
   node.body = this.finishNode(classBody, "ClassBody");
@@ -2144,10 +2474,9 @@
 };
 
 // Parses module export declaration.
-
 pp.parseExport = function (node) {
   this.next();
-  // export * from '...'
+  // Export * from '...'.
   if (this.eat(_tokentype.types.star)) {
     this.expectContextual("from");
     node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
@@ -2155,7 +2484,7 @@
     return this.finishNode(node, "ExportAllDeclaration");
   }
   if (this.eat(_tokentype.types._default)) {
-    // export default ...
+    // Export default ...
     var parens = this.type == _tokentype.types.parenL;
     var expr = this.parseMaybeAssign();
     var needsSemi = true;
@@ -2166,22 +2495,26 @@
       }
     }
     node.declaration = expr;
-    if (needsSemi) this.semicolon();
+    if (needsSemi) {
+      this.semicolon();
+    }
     return this.finishNode(node, "ExportDefaultDeclaration");
   }
-  // export var|const|let|function|class ...
+  // Export var|const|let|function|class ...
   if (this.shouldParseExportStatement()) {
     node.declaration = this.parseStatement(true);
     node.specifiers = [];
     node.source = null;
-  } else {
-    // export { x, y as z } [from '...']
+  }
+  else {
+    // Export { x, y as z } [from '...'].
     node.declaration = null;
     node.specifiers = this.parseExportSpecifiers();
     if (this.eatContextual("from")) {
       node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
-    } else {
-      // check for keywords used as local names
+    }
+    else {
+      // Check for keywords used as local names.
       for (var i = 0; i < node.specifiers.length; i++) {
         if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
           this.unexpected(node.specifiers[i].local.start);
@@ -2200,17 +2533,21 @@
 };
 
 // Parses a comma-separated list of module exports.
-
 pp.parseExportSpecifiers = function () {
   var nodes = [],
       first = true;
-  // export { x, y as z } [from '...']
+  // Export { x, y as z } [from '...'].
   this.expect(_tokentype.types.braceL);
   while (!this.eat(_tokentype.types.braceR)) {
     if (!first) {
       this.expect(_tokentype.types.comma);
-      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
-    } else first = false;
+      if (this.afterTrailingComma(_tokentype.types.braceR)) {
+        break;
+      }
+    }
+    else {
+      first = false;
+    }
 
     var node = this.startNode();
     node.local = this.parseIdent(this.type === _tokentype.types._default);
@@ -2221,14 +2558,14 @@
 };
 
 // Parses import declaration.
-
 pp.parseImport = function (node) {
   this.next();
-  // import '...'
+  // Import '...'.
   if (this.type === _tokentype.types.string) {
     node.specifiers = empty;
     node.source = this.parseExprAtom();
-  } else {
+  }
+  else {
     node.specifiers = this.parseImportSpecifiers();
     this.expectContextual("from");
     node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
@@ -2238,17 +2575,18 @@
 };
 
 // Parses a comma-separated list of module imports.
-
 pp.parseImportSpecifiers = function () {
   var nodes = [],
       first = true;
   if (this.type === _tokentype.types.name) {
-    // import defaultObj, { x, y as z } from '...'
+    // Import defaultObj, { x, y as z } from '...'.
     var node = this.startNode();
     node.local = this.parseIdent();
     this.checkLVal(node.local, true);
     nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
-    if (!this.eat(_tokentype.types.comma)) return nodes;
+    if (!this.eat(_tokentype.types.comma)) {
+      return nodes;
+    }
   }
   if (this.type === _tokentype.types.star) {
     var node = this.startNode();
@@ -2263,17 +2601,27 @@
   while (!this.eat(_tokentype.types.braceR)) {
     if (!first) {
       this.expect(_tokentype.types.comma);
-      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
-    } else first = false;
+      if (this.afterTrailingComma(_tokentype.types.braceR)) {
+        break;
+      }
+    }
+    else {
+      first = false;
+    }
 
     var node = this.startNode();
     node.imported = this.parseIdent(true);
     if (this.eatContextual("as")) {
       node.local = this.parseIdent();
-    } else {
+    }
+    else {
       node.local = node.imported;
-      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
-      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
+      if (this.isKeyword(node.local.name)) {
+        this.unexpected(node.local.start);
+      }
+      if (this.reservedWordsStrict.test(node.local.name)) {
+        this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
+      }
     }
     this.checkLVal(node.local, true);
     nodes.push(this.finishNode(node, "ImportSpecifier"));
@@ -2282,70 +2630,87 @@
 };
 
 },{"./identifier":2,"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
-// The algorithm used to determine whether a regexp can appear at a
-// given point in the program is loosely based on sweet.js' approach.
-// See https://github.com/mozilla/sweet.js/wiki/design
+  // The algorithm used to determine whether a regexp can appear at a
+  // given point in the program is loosely based on sweet.js' approach.
+  // See https://github.com/mozilla/sweet.js/wiki/design
+  "use strict";
 
-"use strict";
+  exports.__esModule = true;
 
-exports.__esModule = true;
-
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-var _state = _dereq_("./state");
+  var _state = _dereq_("./state");
 
-var _tokentype = _dereq_("./tokentype");
+  var _tokentype = _dereq_("./tokentype");
 
-var _whitespace = _dereq_("./whitespace");
+  var _whitespace = _dereq_("./whitespace");
 
-var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
-  _classCallCheck(this, TokContext);
+  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
+    _classCallCheck(this, TokContext);
 
-  this.token = token;
-  this.isExpr = !!isExpr;
-  this.preserveSpace = !!preserveSpace;
-  this.override = override;
-};
+    this.token = token;
+    this.isExpr = !!isExpr;
+    this.preserveSpace = !!preserveSpace;
+    this.override = override;
+  };
 
-exports.TokContext = TokContext;
-var types = {
-  b_stat: new TokContext("{", false),
-  b_expr: new TokContext("{", true),
-  b_tmpl: new TokContext("${", true),
-  p_stat: new TokContext("(", false),
-  p_expr: new TokContext("(", true),
-  q_tmpl: new TokContext("`", true, true, function (p) {
-    return p.readTmplToken();
-  }),
-  f_expr: new TokContext("function", true)
-};
+  exports.TokContext = TokContext;
+  var types = {
+    b_stat: new TokContext("{", false),
+    b_expr: new TokContext("{", true),
+    b_tmpl: new TokContext("${", true),
+    p_stat: new TokContext("(", false),
+    p_expr: new TokContext("(", true),
+    q_tmpl: new TokContext("`", true, true, function (p) {
+      return p.readTmplToken();
+    }),
+    f_expr: new TokContext("function", true)
+  };
 
-exports.types = types;
-var pp = _state.Parser.prototype;
+  exports.types = types;
+  var pp = _state.Parser.prototype;
 
-pp.initialContext = function () {
-  return [types.b_stat];
-};
+  pp.initialContext = function () {
+    return [types.b_stat];
+  };
 
 pp.braceIsBlock = function (prevType) {
   if (prevType === _tokentype.types.colon) {
     var _parent = this.curContext();
-    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
+    if (_parent === types.b_stat || _parent === types.b_expr) {
+      return !_parent.isExpr;
+    }
+  }
+  if (prevType === _tokentype.types._return) {
+    return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
+  }
+  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) {
+    return true;
+  }
+  if (prevType == _tokentype.types.braceL) {
+    return this.curContext() === types.b_stat;
   }
-  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
-  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
-  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
   return !this.exprAllowed;
 };
 
 pp.updateContext = function (prevType) {
   var update = undefined,
       type = this.type;
-  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
+  if (type.keyword && prevType == _tokentype.types.dot) {
+    this.exprAllowed = false;
+  }
+  else if (update = type.updateContext) {
+    update.call(this, prevType);
+  }
+  else {
+    this.exprAllowed = type.beforeExpr;
+  }
 };
 
-// Token-specific context update code
-
+// Token-specific context update code.
 _tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
   if (this.context.length == 1) {
     this.exprAllowed = true;
@@ -2355,9 +2720,11 @@
   if (out === types.b_stat && this.curContext() === types.f_expr) {
     this.context.pop();
     this.exprAllowed = false;
-  } else if (out === types.b_tmpl) {
+  }
+  else if (out === types.b_tmpl) {
     this.exprAllowed = true;
-  } else {
+  }
+  else {
     this.exprAllowed = !out.isExpr;
   }
 };
@@ -2379,96 +2746,109 @@
 };
 
 _tokentype.types.incDec.updateContext = function () {
-  // tokExprAllowed stays unchanged
+  // tokExprAllowed stays unchanged.
 };
 
 _tokentype.types._function.updateContext = function () {
-  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
+  if (this.curContext() !== types.b_stat) {
+    this.context.push(types.f_expr);
+  }
   this.exprAllowed = false;
 };
 
 _tokentype.types.backQuote.updateContext = function () {
-  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
+  if (this.curContext() === types.q_tmpl) {
+    this.context.pop();
+  }
+  else {
+    this.context.push(types.q_tmpl);
+  }
   this.exprAllowed = false;
 };
 
 },{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
-"use strict";
-
-exports.__esModule = true;
+  "use strict";
 
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+  exports.__esModule = true;
 
-var _identifier = _dereq_("./identifier");
-
-var _tokentype = _dereq_("./tokentype");
-
-var _state = _dereq_("./state");
-
-var _locutil = _dereq_("./locutil");
-
-var _whitespace = _dereq_("./whitespace");
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-// Object type used to represent tokens. Note that normally, tokens
-// simply exist as properties on the parser object. This is only
-// used for the onToken callback and the external tokenizer.
+  var _identifier = _dereq_("./identifier");
 
-var Token = function Token(p) {
-  _classCallCheck(this, Token);
+  var _tokentype = _dereq_("./tokentype");
 
-  this.type = p.type;
-  this.value = p.value;
-  this.start = p.start;
-  this.end = p.end;
-  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
-  if (p.options.ranges) this.range = [p.start, p.end];
-}
+  var _state = _dereq_("./state");
 
-// ## Tokenizer
+  var _locutil = _dereq_("./locutil");
 
-;
+  var _whitespace = _dereq_("./whitespace");
 
-exports.Token = Token;
-var pp = _state.Parser.prototype;
+  // Object type used to represent tokens. Note that normally, tokens
+  // simply exist as properties on the parser object. This is only
+  // used for the onToken callback and the external tokenizer.
+  var Token = function Token(p) {
+    _classCallCheck(this, Token);
 
-// Are we running under Rhino?
-var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
+    this.type = p.type;
+    this.value = p.value;
+    this.start = p.start;
+    this.end = p.end;
+    if (p.options.locations) {
+      this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
+    }
+    if (p.options.ranges) {
+      this.range = [p.start, p.end];
+    }
+  };
 
-// Move to the next token
+  exports.Token = Token;
+  var pp = _state.Parser.prototype;
 
-pp.next = function () {
-  if (this.options.onToken) this.options.onToken(new Token(this));
+  // Are we running under Rhino?
+  var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
 
-  this.lastTokEnd = this.end;
-  this.lastTokStart = this.start;
-  this.lastTokEndLoc = this.endLoc;
-  this.lastTokStartLoc = this.startLoc;
-  this.nextToken();
-};
+  // Move to the next token.
+  pp.next = function () {
+    if (this.options.onToken) {
+      this.options.onToken(new Token(this));
+    }
+
+    this.lastTokEnd = this.end;
+    this.lastTokStart = this.start;
+    this.lastTokEndLoc = this.endLoc;
+    this.lastTokStartLoc = this.startLoc;
+    this.nextToken();
+  };
 
 pp.getToken = function () {
   this.next();
   return new Token(this);
 };
 
-// If we're in an ES6 environment, make parsers iterable
-if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
-  var self = this;
-  return { next: function next() {
-      var token = self.getToken();
-      return {
-        done: token.type === _tokentype.types.eof,
-        value: token
-      };
+// If we're in an ES6 environment, make parsers iterable.
+if (typeof Symbol !== "undefined") {
+  pp[Symbol.iterator] = function () {
+    var self = this;
+    return { next: function next() {
+        var token = self.getToken();
+        return {
+          done: token.type === _tokentype.types.eof,
+          value: token
+        };
     } };
+  }
 };
 
 // Toggle strict mode. Re-reads the next number or string to please
 // pedantic tests (`"use strict"; 010;` should fail).
-
 pp.setStrict = function (strict) {
   this.strict = strict;
-  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
+  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) {
+    return;
+  }
   this.pos = this.start;
   if (this.options.locations) {
     while (this.pos < this.lineStart) {
@@ -2485,38 +2865,54 @@
 
 // Read a single token, updating the parser object's token-related
 // properties.
-
 pp.nextToken = function () {
   var curContext = this.curContext();
-  if (!curContext || !curContext.preserveSpace) this.skipSpace();
+  if (!curContext || !curContext.preserveSpace) {
+    this.skipSpace();
+  }
 
   this.start = this.pos;
-  if (this.options.locations) this.startLoc = this.curPosition();
-  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);
+  if (this.options.locations) {
+    this.startLoc = this.curPosition();
+  }
+  if (this.pos >= this.input.length) {
+    return this.finishToken(_tokentype.types.eof);
+  }
 
-  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
+  if (curContext.override) {
+    return curContext.override(this);
+  }
+  else {
+    this.readToken(this.fullCharCodeAtPos());
+  }
 };
 
 pp.readToken = function (code) {
   // Identifier or keyword. '\uXXXX' sequences are allowed in
   // identifiers, so '\' also dispatches to that.
-  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();
+  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) {
+    return this.readWord();
+  }
 
   return this.getTokenFromCode(code);
 };
 
 pp.fullCharCodeAtPos = function () {
   var code = this.input.charCodeAt(this.pos);
-  if (code <= 0xd7ff || code >= 0xe000) return code;
+  if (code <= 0xd7ff || code >= 0xe000) {
+    return code;
+  }
   var next = this.input.charCodeAt(this.pos + 1);
-  return (code << 10) + next - 0x35fdc00;
+  return (code < < 10) + next - 0x35fdc00;
 };
 
 pp.skipBlockComment = function () {
   var startLoc = this.options.onComment && this.curPosition();
   var start = this.pos,
       end = this.input.indexOf("*/", this.pos += 2);
-  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
+  if (end === -1) {
+    this.raise(this.pos - 2, "Unterminated comment");
+  }
   this.pos = end + 2;
   if (this.options.locations) {
     _whitespace.lineBreakG.lastIndex = start;
@@ -2526,7 +2922,9 @@
       this.lineStart = match.index + match[0].length;
     }
   }
-  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
+  if (this.options.onComment) {
+    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
+  }
 };
 
 pp.skipLineComment = function (startSkip) {
@@ -2537,49 +2935,56 @@
     ++this.pos;
     ch = this.input.charCodeAt(this.pos);
   }
-  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
+  if (this.options.onComment) {
+    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
+  }
 };
 
 // Called at the start of the parse and after every token. Skips
 // whitespace and comments, and.
-
 pp.skipSpace = function () {
   loop: while (this.pos < this.input.length) {
     var ch = this.input.charCodeAt(this.pos);
     switch (ch) {
       case 32:case 160:
-        // ' '
-        ++this.pos;
+          // ' '.
+          ++this.pos;
         break;
+
       case 13:
         if (this.input.charCodeAt(this.pos + 1) === 10) {
           ++this.pos;
         }
       case 10:case 8232:case 8233:
-        ++this.pos;
-        if (this.options.locations) {
-          ++this.curLine;
-          this.lineStart = this.pos;
-        }
+            ++this.pos;
+            if (this.options.locations) {
+              ++this.curLine;
+              this.lineStart = this.pos;
+            }
         break;
+
       case 47:
-        // '/'
+        // '/'.
         switch (this.input.charCodeAt(this.pos + 1)) {
           case 42:
-            // '*'
+            // '*'.
             this.skipBlockComment();
             break;
+
           case 47:
             this.skipLineComment(2);
             break;
+
           default:
             break loop;
         }
         break;
+
       default:
         if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
           ++this.pos;
-        } else {
+        }
+        else {
           break loop;
         }
     }
@@ -2590,10 +2995,11 @@
 // maintains `context` and `exprAllowed`, and skips the space after
 // the token, so that the next one's `start` will point at the
 // right position.
-
 pp.finishToken = function (type, val) {
   this.end = this.pos;
-  if (this.options.locations) this.endLoc = this.curPosition();
+  if (this.options.locations) {
+    this.endLoc = this.curPosition();
+  }
   var prevType = this.type;
   this.type = type;
   this.value = val;
@@ -2601,8 +3007,7 @@
   this.updateContext(prevType);
 };
 
-// ### Token reading
-
+// ### Token reading.
 // This is the function that is called to fetch the next token. It
 // is somewhat obscure, because it works in character codes rather
 // than characters, and because operator parsing has been inlined
@@ -2612,102 +3017,125 @@
 //
 pp.readToken_dot = function () {
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next >= 48 && next <= 57) return this.readNumber(true);
+  if (next >= 48 && next <= 57) {
+    return this.readNumber(true);
+  }
   var next2 = this.input.charCodeAt(this.pos + 2);
   if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
-    // 46 = dot '.'
+    // 46 = dot '.'.
     this.pos += 3;
     return this.finishToken(_tokentype.types.ellipsis);
-  } else {
+  }
+  else {
     ++this.pos;
     return this.finishToken(_tokentype.types.dot);
   }
 };
 
 pp.readToken_slash = function () {
-  // '/'
+  // '/'.
   var next = this.input.charCodeAt(this.pos + 1);
   if (this.exprAllowed) {
     ++this.pos;return this.readRegexp();
   }
-  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
+  if (next === 61) {
+    return this.finishOp(_tokentype.types.assign, 2);
+  }
   return this.finishOp(_tokentype.types.slash, 1);
 };
 
 pp.readToken_mult_modulo_exp = function (code) {
-  // '%*'
+  // '%*'.
   var next = this.input.charCodeAt(this.pos + 1);
   var size = 1;
   var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;
 
-  // exponentiation operator ** and **=
+  // Exponentiation operator ** and **=.
   if (this.options.ecmaVersion >= 7 && next === 42) {
     ++size;
     tokentype = _tokentype.types.starstar;
     next = this.input.charCodeAt(this.pos + 2);
   }
 
-  if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
+  if (next === 61) {
+    return this.finishOp(_tokentype.types.assign, size + 1);
+  }
   return this.finishOp(tokentype, size);
 };
 
 pp.readToken_pipe_amp = function (code) {
-  // '|&'
+  // '|&'.
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
-  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
+  if (next === code) {
+    return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
+  }
+  if (next === 61) {
+    return this.finishOp(_tokentype.types.assign, 2);
+  }
   return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
 };
 
 pp.readToken_caret = function () {
-  // '^'
+  // '^'.
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
+  if (next === 61) {
+    return this.finishOp(_tokentype.types.assign, 2);
+  }
   return this.finishOp(_tokentype.types.bitwiseXOR, 1);
 };
 
 pp.readToken_plus_min = function (code) {
-  // '+-'
+  // '+-'.
   var next = this.input.charCodeAt(this.pos + 1);
   if (next === code) {
     if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
-      // A `-->` line comment
+      // A `-->` line comment.
       this.skipLineComment(3);
       this.skipSpace();
       return this.nextToken();
     }
     return this.finishOp(_tokentype.types.incDec, 2);
   }
-  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
+  if (next === 61) {
+    return this.finishOp(_tokentype.types.assign, 2);
+  }
   return this.finishOp(_tokentype.types.plusMin, 1);
 };
 
 pp.readToken_lt_gt = function (code) {
-  // '<>'
+  // '<>'.
   var next = this.input.charCodeAt(this.pos + 1);
   var size = 1;
   if (next === code) {
     size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
-    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
+    if (this.input.charCodeAt(this.pos + size) === 61) {
+      return this.finishOp(_tokentype.types.assign, size + 1);
+    }
     return this.finishOp(_tokentype.types.bitShift, size);
   }
   if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
-    if (this.inModule) this.unexpected();
-    // `<!--`, an XML-style comment that should be interpreted as a line comment
+    if (this.inModule) {
+      this.unexpected();
+    }
+    // `<!--`, an XML-style comment that should be interpreted as a line comment.
     this.skipLineComment(4);
     this.skipSpace();
     return this.nextToken();
   }
-  if (next === 61) size = 2;
+  if (next === 61) {
+    size = 2;
+  }
   return this.finishOp(_tokentype.types.relational, size);
 };
 
 pp.readToken_eq_excl = function (code) {
-  // '=!'
+  // '=!'.
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
+  if (next === 61) {
+    return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
+  }
   if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
-    // '=>'
+    // '=>'.
     this.pos += 2;
     return this.finishToken(_tokentype.types.arrow);
   }
@@ -2719,91 +3147,118 @@
     // The interpretation of a dot depends on whether it is followed
     // by a digit or another two dots.
     case 46:
-      // '.'
+      // '.'.
       return this.readToken_dot();
 
     // Punctuation tokens.
     case 40:
-      ++this.pos;return this.finishToken(_tokentype.types.parenL);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.parenL);
+
     case 41:
-      ++this.pos;return this.finishToken(_tokentype.types.parenR);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.parenR);
+
     case 59:
-      ++this.pos;return this.finishToken(_tokentype.types.semi);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.semi);
+
     case 44:
-      ++this.pos;return this.finishToken(_tokentype.types.comma);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.comma);
+
     case 91:
-      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.bracketL);
+
     case 93:
-      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.bracketR);
+
     case 123:
-      ++this.pos;return this.finishToken(_tokentype.types.braceL);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.braceL);
+
     case 125:
-      ++this.pos;return this.finishToken(_tokentype.types.braceR);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.braceR);
+
     case 58:
-      ++this.pos;return this.finishToken(_tokentype.types.colon);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.colon);
+
     case 63:
-      ++this.pos;return this.finishToken(_tokentype.types.question);
+      ++this.pos;
+      return this.finishToken(_tokentype.types.question);
 
     case 96:
-      // '`'
-      if (this.options.ecmaVersion < 6) break;
+      // '`'.
+      if (this.options.ecmaVersion < 6) {
+        break;
+      }
       ++this.pos;
       return this.finishToken(_tokentype.types.backQuote);
 
     case 48:
-      // '0'
+      // '0'.
       var next = this.input.charCodeAt(this.pos + 1);
-      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
-      if (this.options.ecmaVersion >= 6) {
-        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
-        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
+      if (next === 120 || next === 88) {
+        // '0x', '0X' - hex number.
+        return this.readRadixNumber(16);
+      }      if (this.options.ecmaVersion >= 6) {
+        // '0o', '0O' - octal number.
+        if (next === 111 || next === 79) {
+          return this.readRadixNumber(8);
+        }        if (next === 98 || next === 66) {
+          // '0b', '0B' - binary number.
+          return this.readRadixNumber(2);
+        }
       }
-    // Anything else beginning with a digit is an integer, octal
-    // number, or float.
+      // Anything else beginning with a digit is an integer, octal
+      // number, or float.
     case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
-      // 1-9
+                      // 1-9.
       return this.readNumber(false);
 
     // Quotes produce strings.
     case 34:case 39:
-      // '"', "'"
+        // '"', "'".
       return this.readString(code);
 
     // Operators are parsed inline in tiny state machines. '=' (61) is
     // often referred to. `finishOp` simply skips the amount of
     // characters it is given as second argument, and returns a token
     // of the type given by its first argument.
-
     case 47:
-      // '/'
+      // '/'.
       return this.readToken_slash();
 
     case 37:case 42:
-      // '%*'
+        // '%*'.
       return this.readToken_mult_modulo_exp(code);
 
     case 124:case 38:
-      // '|&'
+        // '|&'.
       return this.readToken_pipe_amp(code);
 
     case 94:
-      // '^'
+      // '^'.
       return this.readToken_caret();
 
     case 43:case 45:
-      // '+-'
+        // '+-'.
       return this.readToken_plus_min(code);
 
     case 60:case 62:
-      // '<>'
+        // '<>'.
       return this.readToken_lt_gt(code);
 
     case 61:case 33:
-      // '=!'
+        // '=!'.
       return this.readToken_eq_excl(code);
 
     case 126:
-      // '~'
+      // '~'.
       return this.finishOp(_tokentype.types.prefix, 1);
   }
 
@@ -2818,13 +3273,15 @@
 
 // Parse a regular expression. Some context-awareness is necessary,
 // since a '/' inside a '[]' set does not end the expression.
-
 function tryCreateRegexp(src, flags, throwErrorAt, parser) {
   try {
     return new RegExp(src, flags);
-  } catch (e) {
+  }
+  catch (e) {
     if (throwErrorAt !== undefined) {
-      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
+      if (e instanceof SyntaxError) {
+        parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
+      }
       throw e;
     }
   }
@@ -2839,13 +3296,28 @@
       inClass = undefined,
       start = this.pos;
   for (;;) {
-    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
+    if (this.pos >= this.input.length) {
+      this.raise(start, "Unterminated regular expression");
+    }
     var ch = this.input.charAt(this.pos);
-    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
+    if (_whitespace.lineBreak.test(ch)) {
+      this.raise(start, "Unterminated regular expression");
+    }
     if (!escaped) {
-      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
+      if (ch === "[") {
+        inClass = true;
+      }
+      else if (ch === "]" && inClass) {
+        inClass = false;
+      }
+      else if (ch === "/" && !inClass) {
+        break;
+      }
       escaped = ch === "\\";
-    } else escaped = false;
+    }
+    else {
+      escaped = false;
+    }
     ++this.pos;
   }
   var content = this.input.slice(start, this.pos);
@@ -2856,8 +3328,12 @@
   var tmp = content;
   if (mods) {
     var validFlags = /^[gim]*$/;
-    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
-    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
+    if (this.options.ecmaVersion >= 6) {
+      validFlags = /^[gimuy]*$/;
+    }
+    if (!validFlags.test(mods)) {
+      this.raise(start, "Invalid regular expression flag");
+    }
     if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
       // Replace each astral symbol and every Unicode escape sequence that
       // possibly represents an astral symbol or a paired surrogate with a
@@ -2869,7 +3345,9 @@
       // be replaced by `[x-b]` which throws an error.
       tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
         code = Number("0x" + code);
-        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
+        if (code > 0x10FFFF) {
+          _this.raise(start + offset + 3, "Code point out of bounds");
+        }
         return "x";
       });
       tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
@@ -2878,7 +3356,7 @@
   // Detect invalid regular expressions.
   var value = null;
   // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
-  // so don't do detection if we are running under Rhino
+  // so don't do detection if we are running under Rhino.
   if (!isRhino) {
     tryCreateRegexp(tmp, undefined, start, this);
     // Get a regular expression object for this pattern-flag pair, or `null` in
@@ -2891,103 +3369,153 @@
 // Read an integer in the given radix. Return null if zero digits
 // were read, the integer value otherwise. When `len` is given, this
 // will return `null` unless the integer has exactly `len` digits.
-
 pp.readInt = function (radix, len) {
   var start = this.pos,
       total = 0;
   for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
     var code = this.input.charCodeAt(this.pos),
         val = undefined;
-    if (code >= 97) val = code - 97 + 10; // a
-    else if (code >= 65) val = code - 65 + 10; // A
-      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
-        else val = Infinity;
-    if (val >= radix) break;
+    // A.
+    if (code >= 97) {
+      val = code - 97 + 10;
+    }
+    else if (code >= 65) {
+      // A.
+      val = code - 65 + 10;
+    }
+    else if (code >= 48 && code <= 57) {
+      // 0-9.
+      val = code - 48;
+    }
+    else {
+      val = Infinity;
+    }
+    if (val >= radix) {
+      break;
+    }
     ++this.pos;
     total = total * radix + val;
   }
-  if (this.pos === start || len != null && this.pos - start !== len) return null;
+  if (this.pos === start || len != null && this.pos - start !== len) {
+    return null;
+  }
 
   return total;
 };
 
 pp.readRadixNumber = function (radix) {
-  this.pos += 2; // 0x
+  // 0x.
+  this.pos += 2;
   var val = this.readInt(radix);
-  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
-  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
+  if (val == null) {
+    this.raise(this.start + 2, "Expected number in radix " + radix);
+  }
+  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) {
+    this.raise(this.pos, "Identifier directly after number");
+  }
   return this.finishToken(_tokentype.types.num, val);
 };
 
 // Read an integer, octal integer, or floating-point number.
-
 pp.readNumber = function (startsWithDot) {
   var start = this.pos,
       isFloat = false,
       octal = this.input.charCodeAt(this.pos) === 48;
-  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
+  if (!startsWithDot && this.readInt(10) === null) {
+    this.raise(start, "Invalid number");
+  }
   var next = this.input.charCodeAt(this.pos);
   if (next === 46) {
-    // '.'
+    // '.'.
     ++this.pos;
     this.readInt(10);
     isFloat = true;
     next = this.input.charCodeAt(this.pos);
   }
   if (next === 69 || next === 101) {
-    // 'eE'
+    // 'eE'.
     next = this.input.charCodeAt(++this.pos);
-    if (next === 43 || next === 45) ++this.pos; // '+-'
-    if (this.readInt(10) === null) this.raise(start, "Invalid number");
+    if (next === 43 || next === 45) {
+      // '+-'.
+      ++this.pos;
+    }    if (this.readInt(10) === null) {
+      this.raise(start, "Invalid number");
+    }
     isFloat = true;
   }
-  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
+  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) {
+    this.raise(this.pos, "Identifier directly after number");
+  }
 
   var str = this.input.slice(start, this.pos),
       val = undefined;
-  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
+  if (isFloat) {
+    val = parseFloat(str);
+  }
+  else if (!octal || str.length === 1) {
+    val = parseInt(str, 10);
+  }
+  else if (/[89]/.test(str) || this.strict) {
+    this.raise(start, "Invalid number");
+  }
+  else {
+    val = parseInt(str, 8);
+  }
   return this.finishToken(_tokentype.types.num, val);
 };
 
 // Read a string value, interpreting backslash-escapes.
-
 pp.readCodePoint = function () {
   var ch = this.input.charCodeAt(this.pos),
       code = undefined;
 
   if (ch === 123) {
-    if (this.options.ecmaVersion < 6) this.unexpected();
+    if (this.options.ecmaVersion < 6) {
+      this.unexpected();
+    }
     var codePos = ++this.pos;
     code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
     ++this.pos;
-    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
-  } else {
+    if (code > 0x10FFFF) {
+      this.raise(codePos, "Code point out of bounds");
+    }
+  }
+  else {
     code = this.readHexChar(4);
   }
   return code;
 };
 
 function codePointToString(code) {
-  // UTF-16 Decoding
-  if (code <= 0xFFFF) return String.fromCharCode(code);
+  // UTF-16 Decoding.
+  if (code <= 0xFFFF) {
+    return String.fromCharCode(code);
+  }
   code -= 0x10000;
-  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
+  return String.fromCharCode((code > > 10) + 0xD800, (code & 1023) + 0xDC00);
 }
 
 pp.readString = function (quote) {
   var out = "",
       chunkStart = ++this.pos;
   for (;;) {
-    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
+    if (this.pos >= this.input.length) {
+      this.raise(this.start, "Unterminated string constant");
+    }
     var ch = this.input.charCodeAt(this.pos);
-    if (ch === quote) break;
+    if (ch === quote) {
+      break;
+    }
     if (ch === 92) {
-      // '\'
+      // '\'.
       out += this.input.slice(chunkStart, this.pos);
       out += this.readEscapedChar(false);
       chunkStart = this.pos;
-    } else {
-      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
+    }
+    else {
+      if (_whitespace.isNewLine(ch)) {
+        this.raise(this.start, "Unterminated string constant");
+      }
       ++this.pos;
     }
   }
@@ -2996,20 +3524,22 @@
 };
 
 // Reads template string tokens.
-
 pp.readTmplToken = function () {
   var out = "",
       chunkStart = this.pos;
   for (;;) {
-    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
+    if (this.pos >= this.input.length) {
+      this.raise(this.start, "Unterminated template");
+    }
     var ch = this.input.charCodeAt(this.pos);
     if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
-      // '`', '${'
+      // '`', '${'.
       if (this.pos === this.start && this.type === _tokentype.types.template) {
         if (ch === 36) {
           this.pos += 2;
           return this.finishToken(_tokentype.types.dollarBraceL);
-        } else {
+        }
+        else {
           ++this.pos;
           return this.finishToken(_tokentype.types.backQuote);
         }
@@ -3018,19 +3548,23 @@
       return this.finishToken(_tokentype.types.template, out);
     }
     if (ch === 92) {
-      // '\'
+      // '\'.
       out += this.input.slice(chunkStart, this.pos);
       out += this.readEscapedChar(true);
       chunkStart = this.pos;
-    } else if (_whitespace.isNewLine(ch)) {
+    }
+    else if (_whitespace.isNewLine(ch)) {
       out += this.input.slice(chunkStart, this.pos);
       ++this.pos;
       switch (ch) {
         case 13:
-          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
+          if (this.input.charCodeAt(this.pos) === 10) {
+            ++this.pos;
+          }
         case 10:
           out += "\n";
           break;
+
         default:
           out += String.fromCharCode(ch);
           break;
@@ -3040,42 +3574,61 @@
         this.lineStart = this.pos;
       }
       chunkStart = this.pos;
-    } else {
+    }
+    else {
       ++this.pos;
     }
   }
 };
 
-// Used to read escaped characters
-
+// Used to read escaped characters.
 pp.readEscapedChar = function (inTemplate) {
   var ch = this.input.charCodeAt(++this.pos);
   ++this.pos;
   switch (ch) {
     case 110:
-      return "\n"; // 'n' -> '\n'
+      return "\n";
+
+    // 'n' -> '\n'.
     case 114:
-      return "\r"; // 'r' -> '\r'
+      return "\r";
+
+    // 'r' -> '\r'.
     case 120:
-      return String.fromCharCode(this.readHexChar(2)); // 'x'
+      return String.fromCharCode(this.readHexChar(2));
+
+    // 'x'.
     case 117:
-      return codePointToString(this.readCodePoint()); // 'u'
+      return codePointToString(this.readCodePoint());
+
+    // 'u'.
     case 116:
-      return "\t"; // 't' -> '\t'
+      return "\t";
+
+    // 't' -> '\t'.
     case 98:
-      return "\b"; // 'b' -> '\b'
+      return "\b";
+
+    // 'b' -> '\b'.
     case 118:
-      return "\u000b"; // 'v' -> '\u000b'
+      return "\u000b";
+
+    // 'v' -> '\u000b'.
     case 102:
-      return "\f"; // 'f' -> '\f'
+      return "\f";
+
+    // 'f' -> '\f'.
     case 13:
-      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
-    case 10:
-      // ' \n'
-      if (this.options.locations) {
-        this.lineStart = this.pos;++this.curLine;
-      }
+      if (this.input.charCodeAt(this.pos) === 10) {
+        // '\r\n'.
+        ++this.pos;
+      }    case 10:
+            // ' \n'.
+            if (this.options.locations) {
+              this.lineStart = this.pos;++this.curLine;
+            }
       return "";
+
     default:
       if (ch >= 48 && ch <= 55) {
         var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
@@ -3095,11 +3648,12 @@
 };
 
 // Used to read character escape sequences ('\x', '\u', '\U').
-
 pp.readHexChar = function (len) {
   var codePos = this.pos;
   var n = this.readInt(16, len);
-  if (n === null) this.raise(codePos, "Bad character escape sequence");
+  if (n === null) {
+    this.raise(codePos, "Bad character escape sequence");
+  }
   return n;
 };
 
@@ -3108,7 +3662,6 @@
 //
 // Incrementally adds only escaped chars, adding other chunks as-is
 // as a micro-optimization.
-
 pp.readWord1 = function () {
   this.containsEsc = false;
   var word = "",
@@ -3119,19 +3672,26 @@
     var ch = this.fullCharCodeAtPos();
     if (_identifier.isIdentifierChar(ch, astral)) {
       this.pos += ch <= 0xffff ? 1 : 2;
-    } else if (ch === 92) {
-      // "\"
+    }
+    else if (ch === 92) {
+      // "\".
       this.containsEsc = true;
       word += this.input.slice(chunkStart, this.pos);
       var escStart = this.pos;
-      if (this.input.charCodeAt(++this.pos) != 117) // "u"
+      // "u".
+      if (this.input.charCodeAt(++this.pos) != 117) {
+
         this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
+      }
       ++this.pos;
       var esc = this.readCodePoint();
-      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
+      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) {
+        this.raise(escStart, "Invalid Unicode escape");
+      }
       word += codePointToString(esc);
       chunkStart = this.pos;
-    } else {
+    }
+    else {
       break;
     }
     first = false;
@@ -3141,217 +3701,214 @@
 
 // Read an identifier or keyword token. Will check for reserved
 // words when necessary.
-
 pp.readWord = function () {
   var word = this.readWord1();
   var type = _tokentype.types.name;
-  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
+  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) {
+    type = _tokentype.keywords[word];
+  }
   return this.finishToken(type, word);
 };
 
 },{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
-// ## Token types
-
-// The assignment of fine-grained, information-carrying type objects
-// allows the tokenizer to store the information it has about a
-// token in a way that is very cheap for the parser to look up.
-
-// All token type variables start with an underscore, to make them
-// easy to recognize.
-
-// The `beforeExpr` property is used to disambiguate between regular
-// expressions and divisions. It is set on all token types that can
-// be followed by an expression (thus, a slash after them would be a
-// regular expression).
-//
-// The `startsExpr` property is used to check if the token ends a
-// `yield` expression. It is set on all token types that either can
-// directly start an expression (like a quotation mark) or can
-// continue an expression (like the body of a string).
-//
-// `isLoop` marks a keyword as starting a loop, which is important
-// to know when parsing a label, in order to allow or disallow
-// continue jumps to that label.
-
-"use strict";
+  // ## Token types
+  // The assignment of fine-grained, information-carrying type objects
+  // allows the tokenizer to store the information it has about a
+  // token in a way that is very cheap for the parser to look up.
+  // All token type variables start with an underscore, to make them
+  // easy to recognize.
+  // The `beforeExpr` property is used to disambiguate between regular
+  // expressions and divisions. It is set on all token types that can
+  // be followed by an expression (thus, a slash after them would be a
+  // regular expression).
+  //
+  // The `startsExpr` property is used to check if the token ends a
+  // `yield` expression. It is set on all token types that either can
+  // directly start an expression (like a quotation mark) or can
+  // continue an expression (like the body of a string).
+  //
+  // `isLoop` marks a keyword as starting a loop, which is important
+  // to know when parsing a label, in order to allow or disallow
+  // continue jumps to that label.
+  "use strict";
 
-exports.__esModule = true;
+  exports.__esModule = true;
 
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-var TokenType = function TokenType(label) {
-  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
+  var TokenType = function TokenType(label) {
+    var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
 
-  _classCallCheck(this, TokenType);
+    _classCallCheck(this, TokenType);
 
-  this.label = label;
-  this.keyword = conf.keyword;
-  this.beforeExpr = !!conf.beforeExpr;
-  this.startsExpr = !!conf.startsExpr;
-  this.isLoop = !!conf.isLoop;
-  this.isAssign = !!conf.isAssign;
-  this.prefix = !!conf.prefix;
-  this.postfix = !!conf.postfix;
-  this.binop = conf.binop || null;
-  this.updateContext = null;
-};
+    this.label = label;
+    this.keyword = conf.keyword;
+    this.beforeExpr = !!conf.beforeExpr;
+    this.startsExpr = !!conf.startsExpr;
+    this.isLoop = !!conf.isLoop;
+    this.isAssign = !!conf.isAssign;
+    this.prefix = !!conf.prefix;
+    this.postfix = !!conf.postfix;
+    this.binop = conf.binop || null;
+    this.updateContext = null;
+  };
 
-exports.TokenType = TokenType;
+  exports.TokenType = TokenType;
 
-function binop(name, prec) {
-  return new TokenType(name, { beforeExpr: true, binop: prec });
-}
-var beforeExpr = { beforeExpr: true },
+  function binop(name, prec) {
+    return new TokenType(name, { beforeExpr: true, binop: prec });
+  }
+  var beforeExpr = { beforeExpr: true },
     startsExpr = { startsExpr: true };
 
-var types = {
-  num: new TokenType("num", startsExpr),
-  regexp: new TokenType("regexp", startsExpr),
-  string: new TokenType("string", startsExpr),
-  name: new TokenType("name", startsExpr),
-  eof: new TokenType("eof"),
-
-  // Punctuation token types.
-  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
-  bracketR: new TokenType("]"),
-  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
-  braceR: new TokenType("}"),
-  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
-  parenR: new TokenType(")"),
-  comma: new TokenType(",", beforeExpr),
-  semi: new TokenType(";", beforeExpr),
-  colon: new TokenType(":", beforeExpr),
-  dot: new TokenType("."),
-  question: new TokenType("?", beforeExpr),
-  arrow: new TokenType("=>", beforeExpr),
-  template: new TokenType("template"),
-  ellipsis: new TokenType("...", beforeExpr),
-  backQuote: new TokenType("`", startsExpr),
-  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
-
-  // Operators. These carry several kinds of properties to help the
-  // parser use them properly (the presence of these properties is
-  // what categorizes them as operators).
-  //
-  // `binop`, when present, specifies that this operator is a binary
-  // operator, and will refer to its precedence.
-  //
-  // `prefix` and `postfix` mark the operator as a prefix or postfix
-  // unary operator.
-  //
-  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
-  // binary operators with a very low precedence, that should result
-  // in AssignmentExpression nodes.
-
-  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
-  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
-  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
-  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
-  logicalOR: binop("||", 1),
-  logicalAND: binop("&&", 2),
-  bitwiseOR: binop("|", 3),
-  bitwiseXOR: binop("^", 4),
-  bitwiseAND: binop("&", 5),
-  equality: binop("==/!=", 6),
-  relational: binop("</>", 7),
-  bitShift: binop("<</>>", 8),
-  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
-  modulo: binop("%", 10),
-  star: binop("*", 10),
-  slash: binop("/", 10),
-  starstar: new TokenType("**", { beforeExpr: true })
-};
-
-exports.types = types;
-// Map keyword names to token types.
-
-var keywords = {};
-
-exports.keywords = keywords;
-// Succinct definitions of keyword token types
-function kw(name) {
-  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
-
-  options.keyword = name;
-  keywords[name] = types["_" + name] = new TokenType(name, options);
-}
+  var types = {
+    num: new TokenType("num", startsExpr),
+    regexp: new TokenType("regexp", startsExpr),
+    string: new TokenType("string", startsExpr),
+    name: new TokenType("name", startsExpr),
+    eof: new TokenType("eof"),
+
+    // Punctuation token types.
+    bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
+    bracketR: new TokenType("]"),
+    braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
+    braceR: new TokenType("}"),
+    parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
+    parenR: new TokenType(")"),
+    comma: new TokenType(",", beforeExpr),
+    semi: new TokenType(";", beforeExpr),
+    colon: new TokenType(":", beforeExpr),
+    dot: new TokenType("."),
+    question: new TokenType("?", beforeExpr),
+    arrow: new TokenType("=>", beforeExpr),
+    template: new TokenType("template"),
+    ellipsis: new TokenType("...", beforeExpr),
+    backQuote: new TokenType("`", startsExpr),
+    dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
+
+    // Operators. These carry several kinds of properties to help the
+    // parser use them properly (the presence of these properties is
+    // what categorizes them as operators).
+    //
+    // `binop`, when present, specifies that this operator is a binary
+    // operator, and will refer to its precedence.
+    //
+    // `prefix` and `postfix` mark the operator as a prefix or postfix
+    // unary operator.
+    //
+    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
+    // binary operators with a very low precedence, that should result
+    // in AssignmentExpression nodes.
+    eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
+    assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
+    incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
+    prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
+    logicalOR: binop("||", 1),
+    logicalAND: binop("&&", 2),
+    bitwiseOR: binop("|", 3),
+    bitwiseXOR: binop("^", 4),
+    bitwiseAND: binop("&", 5),
+    equality: binop("==/!=", 6),
+    relational: binop("</>", 7),
+    bitShift: binop("<</>>", 8),
+    plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
+    modulo: binop("%", 10),
+    star: binop("*", 10),
+    slash: binop("/", 10),
+    starstar: new TokenType("**", { beforeExpr: true })
+  };
 
-kw("break");
-kw("case", beforeExpr);
-kw("catch");
-kw("continue");
-kw("debugger");
-kw("default", beforeExpr);
-kw("do", { isLoop: true, beforeExpr: true });
-kw("else", beforeExpr);
-kw("finally");
-kw("for", { isLoop: true });
-kw("function", startsExpr);
-kw("if");
-kw("return", beforeExpr);
-kw("switch");
-kw("throw", beforeExpr);
-kw("try");
-kw("var");
-kw("const");
-kw("while", { isLoop: true });
-kw("with");
-kw("new", { beforeExpr: true, startsExpr: true });
-kw("this", startsExpr);
-kw("super", startsExpr);
-kw("class");
-kw("extends", beforeExpr);
-kw("export");
-kw("import");
-kw("null", startsExpr);
-kw("true", startsExpr);
-kw("false", startsExpr);
-kw("in", { beforeExpr: true, binop: 7 });
-kw("instanceof", { beforeExpr: true, binop: 7 });
-kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
-kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
-kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });
+  exports.types = types;
+  // Map keyword names to token types.
+  var keywords = {};
+
+  exports.keywords = keywords;
+  // Succinct definitions of keyword token types.
+  function kw(name) {
+    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
+
+    options.keyword = name;
+    keywords[name] = types["_" + name] = new TokenType(name, options);
+  }
+
+  kw("break");
+  kw("case", beforeExpr);
+  kw("catch");
+  kw("continue");
+  kw("debugger");
+  kw("default", beforeExpr);
+  kw("do", { isLoop: true, beforeExpr: true });
+  kw("else", beforeExpr);
+  kw("finally");
+  kw("for", { isLoop: true });
+  kw("function", startsExpr);
+  kw("if");
+  kw("return", beforeExpr);
+  kw("switch");
+  kw("throw", beforeExpr);
+  kw("try");
+  kw("var");
+  kw("const");
+  kw("while", { isLoop: true });
+  kw("with");
+  kw("new", { beforeExpr: true, startsExpr: true });
+  kw("this", startsExpr);
+  kw("super", startsExpr);
+  kw("class");
+  kw("extends", beforeExpr);
+  kw("export");
+  kw("import");
+  kw("null", startsExpr);
+  kw("true", startsExpr);
+  kw("false", startsExpr);
+  kw("in", { beforeExpr: true, binop: 7 });
+  kw("instanceof", { beforeExpr: true, binop: 7 });
+  kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
+  kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
+  kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });
 
 },{}],15:[function(_dereq_,module,exports){
-"use strict";
+  "use strict";
 
-exports.__esModule = true;
-exports.isArray = isArray;
-exports.has = has;
+  exports.__esModule = true;
+  exports.isArray = isArray;
+  exports.has = has;
 
-function isArray(obj) {
-  return Object.prototype.toString.call(obj) === "[object Array]";
-}
-
-// Checks if an object has a property.
+  function isArray(obj) {
+    return Object.prototype.toString.call(obj) === "[object Array]";
+  }
 
-function has(obj, propName) {
-  return Object.prototype.hasOwnProperty.call(obj, propName);
-}
+  // Checks if an object has a property.
+  function has(obj, propName) {
+    return Object.prototype.hasOwnProperty.call(obj, propName);
+  }
 
 },{}],16:[function(_dereq_,module,exports){
-// Matches a whole line break (where CRLF is considered a single
-// line break). Used to count lines.
-
-"use strict";
+  // Matches a whole line break (where CRLF is considered a single
+  // line break). Used to count lines.
+  "use strict";
 
-exports.__esModule = true;
-exports.isNewLine = isNewLine;
-var lineBreak = /\r\n?|\n|\u2028|\u2029/;
-exports.lineBreak = lineBreak;
-var lineBreakG = new RegExp(lineBreak.source, "g");
+  exports.__esModule = true;
+  exports.isNewLine = isNewLine;
+  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
+  exports.lineBreak = lineBreak;
+  var lineBreakG = new RegExp(lineBreak.source, "g");
 
-exports.lineBreakG = lineBreakG;
+  exports.lineBreakG = lineBreakG;
 
-function isNewLine(code) {
-  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
-}
+  function isNewLine(code) {
+    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
+  }
 
-var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
+  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
 
-exports.nonASCIIwhitespace = nonASCIIwhitespace;
-var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
-exports.skipWhiteSpace = skipWhiteSpace;
+  exports.nonASCIIwhitespace = nonASCIIwhitespace;
+  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
+  exports.skipWhiteSpace = skipWhiteSpace;
 
-},{}]},{},[3])(3)
-});
\ No newline at end of file
+},{}]
+},{},[3])(3)
+});

--- themes/c4m/kapablo/build/node_modules/acorn/dist/acorn_loose.js
+++ PHP_CodeSniffer
@@ -1,34 +1,72 @@
-(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
-"use strict";
+/**
+ * @file
+ */
 
-module.exports = typeof acorn != 'undefined' ? acorn : require("./acorn");
+(function(f){if (typeof exports === "object"&&typeof module !== "undefined") {
+    module.exports = f()
+}
+else if (typeof define === "function"&&define.amd) {
+  define([],f)
+}
+else {
+  var g;if (typeof window !== "undefined") {
+    g = window
+  }
+  else if (typeof global !== "undefined") {
+    g = global
+  }
+  else if (typeof self !== "undefined") {
+    g = self
+  }
+  else {
+    g = this
+  }(g.acorn || (g.acorn = {})).loose = f()
+}
+})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if (!n[o]) {
+        if (!t[o]) {
+          var a = typeof require == "function"&&require;if (!u&&a) {
+            return a(o,!0);
+          }if (i) {
+            return i(o,!0);
+          }var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND",f
+        }var l = n[o] = {exports:{}};t[o][0].call(l.exports,function(e){var n = t[o][1][e];return s(n ? n : e)
+        },l,l.exports,e,t,n,r)
+}return n[o].exports
+}var i = typeof require == "function"&&require;for (var o = 0; o < r.length; o++) {
+  s(r[o]);return s
+})(1 :[function(_dereq_,module,exports){
+  "use strict";
 
-},{}],2:[function(_dereq_,module,exports){
-"use strict";
+  module.exports = typeof acorn != 'undefined' ? acorn : require("./acorn");
 
-var _state = _dereq_("./state");
+},{}],2:[function(_dereq_,module,exports){
+  "use strict";
 
-var _parseutil = _dereq_("./parseutil");
+  var _state = _dereq_("./state");
 
-var _ = _dereq_("..");
+  var _parseutil = _dereq_("./parseutil");
 
-var lp = _state.LooseParser.prototype;
+  var _ = _dereq_("..");
 
-lp.checkLVal = function (expr) {
-  if (!expr) return expr;
-  switch (expr.type) {
-    case "Identifier":
-    case "MemberExpression":
-      return expr;
+  var lp = _state.LooseParser.prototype;
 
-    case "ParenthesizedExpression":
-      expr.expression = this.checkLVal(expr.expression);
+  lp.checkLVal = function (expr) {
+    if (!expr) {
       return expr;
+    }
+    switch (expr.type) {
+      case "Identifier":
+      case "MemberExpression":
+        return expr;
+
+      case "ParenthesizedExpression":
+        expr.expression = this.checkLVal(expr.expression);
+        return expr;
 
-    default:
-      return this.dummyIdent();
-  }
-};
+      default:
+        return this.dummyIdent();
+    }
+  };
 
 lp.parseExpression = function (noIn) {
   var start = this.storeCurrentPos();
@@ -36,7 +74,9 @@
   if (this.tok.type === _.tokTypes.comma) {
     var node = this.startNodeAt(start);
     node.expressions = [expr];
-    while (this.eat(_.tokTypes.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
+    while (this.eat(_.tokTypes.comma)) {
+      node.expressions.push(this.parseMaybeAssign(noIn));
+    }
     return this.finishNode(node, "SequenceExpression");
   }
   return expr;
@@ -58,7 +98,8 @@
     if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _.tokTypes.star && !this.tok.type.startsExpr) {
       node.delegate = false;
       node.argument = null;
-    } else {
+    }
+    else {
       node.delegate = this.eat(_.tokTypes.star);
       node.argument = this.parseMaybeAssign();
     }
@@ -99,7 +140,9 @@
 };
 
 lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
-  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
+  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
+    return left;
+  }
   var prec = this.tok.type.binop;
   if (prec != null && (!noIn || this.tok.type !== _.tokTypes._in)) {
     if (prec > minPrec) {
@@ -109,7 +152,8 @@
       this.next();
       if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
         node.right = this.dummyIdent();
-      } else {
+      }
+      else {
         var rightStart = this.storeCurrentPos();
         node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
       }
@@ -126,19 +170,25 @@
   if (this.tok.type.prefix) {
     var node = this.startNode(),
         update = this.tok.type === _.tokTypes.incDec;
-    if (!update) sawUnary = true;
+    if (!update) {
+      sawUnary = true;
+    }
     node.operator = this.tok.value;
     node.prefix = true;
     this.next();
     node.argument = this.parseMaybeUnary(true);
-    if (update) node.argument = this.checkLVal(node.argument);
+    if (update) {
+      node.argument = this.checkLVal(node.argument);
+    }
     expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
-  } else if (this.tok.type === _.tokTypes.ellipsis) {
+  }
+  else if (this.tok.type === _.tokTypes.ellipsis) {
     var node = this.startNode();
     this.next();
     node.argument = this.parseMaybeUnary(sawUnary);
     expr = this.finishNode(node, "SpreadElement");
-  } else {
+  }
+  else {
     expr = this.parseExprSubscripts();
     while (this.tok.type.postfix && !this.canInsertSemicolon()) {
       var node = this.startNodeAt(start);
@@ -169,16 +219,27 @@
 lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
   for (;;) {
     if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
-      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
+      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) {
+        --startIndent;
+      }
+      else {
+        return base;
+      }
     }
 
     if (this.eat(_.tokTypes.dot)) {
       var node = this.startNodeAt(start);
       node.object = base;
-      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
+      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
+        node.property = this.dummyIdent();
+      }
+      else {
+        node.property = this.parsePropertyAccessor() || this.dummyIdent();
+      }
       node.computed = false;
       base = this.finishNode(node, "MemberExpression");
-    } else if (this.tok.type == _.tokTypes.bracketL) {
+    }
+    else if (this.tok.type == _.tokTypes.bracketL) {
       this.pushCx();
       this.next();
       var node = this.startNodeAt(start);
@@ -188,17 +249,20 @@
       this.popCx();
       this.expect(_.tokTypes.bracketR);
       base = this.finishNode(node, "MemberExpression");
-    } else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
+    }
+    else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
       var node = this.startNodeAt(start);
       node.callee = base;
       node.arguments = this.parseExprList(_.tokTypes.parenR);
       base = this.finishNode(node, "CallExpression");
-    } else if (this.tok.type == _.tokTypes.backQuote) {
+    }
+    else if (this.tok.type == _.tokTypes.backQuote) {
       var node = this.startNodeAt(start);
       node.tag = base;
       node.quasi = this.parseTemplate();
       base = this.finishNode(node, "TaggedTemplateExpression");
-    } else {
+    }
+    else {
       return base;
     }
   }
@@ -229,17 +293,17 @@
       return this.finishNode(node, "Literal");
 
     case _.tokTypes.num:case _.tokTypes.string:
-      node = this.startNode();
-      node.value = this.tok.value;
-      node.raw = this.input.slice(this.tok.start, this.tok.end);
-      this.next();
+        node = this.startNode();
+        node.value = this.tok.value;
+        node.raw = this.input.slice(this.tok.start, this.tok.end);
+        this.next();
       return this.finishNode(node, "Literal");
 
     case _.tokTypes._null:case _.tokTypes._true:case _.tokTypes._false:
-      node = this.startNode();
-      node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
-      node.raw = this.tok.type.keyword;
-      this.next();
+          node = this.startNode();
+          node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
+          node.raw = this.tok.type.keyword;
+          this.next();
       return this.finishNode(node, "Literal");
 
     case _.tokTypes.parenL:
@@ -298,7 +362,8 @@
   node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
   if (this.tok.type == _.tokTypes.parenL) {
     node.arguments = this.parseExprList(_.tokTypes.parenR);
-  } else {
+  }
+  else {
     node.arguments = [];
   }
   return this.finishNode(node, "NewExpression");
@@ -326,7 +391,8 @@
     node.expressions.push(this.parseExpression());
     if (this.expect(_.tokTypes.braceR)) {
       curElt = this.parseTemplateElement();
-    } else {
+    }
+    else {
       curElt = this.startNode();
       curElt.value = { cooked: '', raw: '' };
       curElt.tail = true;
@@ -359,20 +425,25 @@
     }
     this.parsePropertyName(prop);
     if (_parseutil.isDummy(prop.key)) {
-      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
+      if (_parseutil.isDummy(this.parseMaybeAssign())) {
+        this.next();
+      }this.eat(_.tokTypes.comma);continue;
     }
     if (this.eat(_.tokTypes.colon)) {
       prop.kind = "init";
       prop.value = this.parseMaybeAssign();
-    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
+    }
+    else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
       prop.kind = "init";
       prop.method = true;
       prop.value = this.parseMethod(isGenerator);
-    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR) {
+    }
+    else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR) {
       prop.kind = prop.key.name;
       this.parsePropertyName(prop);
       prop.value = this.parseMethod(false);
-    } else {
+    }
+    else {
       prop.kind = "init";
       if (this.options.ecmaVersion >= 6) {
         if (this.eat(_.tokTypes.eq)) {
@@ -381,10 +452,12 @@
           assign.left = prop.key;
           assign.right = this.parseMaybeAssign();
           prop.value = this.finishNode(assign, "AssignmentExpression");
-        } else {
+        }
+        else {
           prop.value = prop.key;
         }
-      } else {
+      }
+      else {
         prop.value = this.dummyIdent();
       }
       prop.shorthand = true;
@@ -395,9 +468,11 @@
   this.popCx();
   if (!this.eat(_.tokTypes.braceR)) {
     // If there is no closing brace, make the node span to the start
-    // of the next token (this is useful for Tern)
+    // of the next token (this is useful for Tern).
     this.last.end = this.tok.start;
-    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
+    if (this.options.locations) {
+      this.last.loc.end = this.tok.loc.start;
+    }
   }
   return this.finishNode(node, "ObjectExpression");
 };
@@ -409,7 +484,8 @@
       prop.key = this.parseExpression();
       this.expect(_.tokTypes.bracketR);
       return;
-    } else {
+    }
+    else {
       prop.computed = false;
     }
   }
@@ -418,12 +494,16 @@
 };
 
 lp.parsePropertyAccessor = function () {
-  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
+  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) {
+    return this.parseIdent();
+  }
 };
 
 lp.parseIdent = function () {
   var name = this.tok.type === _.tokTypes.name ? this.tok.value : this.tok.type.keyword;
-  if (!name) return this.dummyIdent();
+  if (!name) {
+    return this.dummyIdent();
+  }
   var node = this.startNode();
   this.next();
   node.name = name;
@@ -441,32 +521,38 @@
 
 // Convert existing expression atom to assignable pattern
 // if possible.
-
 lp.toAssignable = function (node, binding) {
   if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {
-    // Okay
-  } else if (node.type == "ParenthesizedExpression") {
+    // Okay.
+  }
+  else if (node.type == "ParenthesizedExpression") {
       node.expression = this.toAssignable(node.expression, binding);
-    } else if (this.options.ecmaVersion < 6) {
-      return this.dummyIdent();
-    } else if (node.type == "ObjectExpression") {
-      node.type = "ObjectPattern";
-      var props = node.properties;
-      for (var i = 0; i < props.length; i++) {
-        props[i].value = this.toAssignable(props[i].value, binding);
-      }
-    } else if (node.type == "ArrayExpression") {
-      node.type = "ArrayPattern";
-      this.toAssignableList(node.elements, binding);
-    } else if (node.type == "SpreadElement") {
-      node.type = "RestElement";
-      node.argument = this.toAssignable(node.argument, binding);
-    } else if (node.type == "AssignmentExpression") {
-      node.type = "AssignmentPattern";
-      delete node.operator;
-    } else {
-      return this.dummyIdent();
-    }
+  }
+  else if (this.options.ecmaVersion < 6) {
+    return this.dummyIdent();
+  }
+  else if (node.type == "ObjectExpression") {
+    node.type = "ObjectPattern";
+    var props = node.properties;
+    for (var i = 0; i < props.length; i++) {
+      props[i].value = this.toAssignable(props[i].value, binding);
+    }
+  }
+  else if (node.type == "ArrayExpression") {
+    node.type = "ArrayPattern";
+    this.toAssignableList(node.elements, binding);
+  }
+  else if (node.type == "SpreadElement") {
+    node.type = "RestElement";
+    node.argument = this.toAssignable(node.argument, binding);
+  }
+  else if (node.type == "AssignmentExpression") {
+    node.type = "AssignmentPattern";
+    delete node.operator;
+  }
+  else {
+    return this.dummyIdent();
+  }
   return node;
 };
 
@@ -504,7 +590,8 @@
   var indent = this.curIndent,
       line = this.curLineStart,
       elts = [];
-  this.next(); // Opening bracket
+  // Opening bracket.
+  this.next();
   while (!this.closes(close, indent + 1, line)) {
     if (this.eat(_.tokTypes.comma)) {
       elts.push(allowEmpty ? null : this.dummyIdent());
@@ -512,9 +599,12 @@
     }
     var elt = this.parseMaybeAssign();
     if (_parseutil.isDummy(elt)) {
-      if (this.closes(close, indent, line)) break;
+      if (this.closes(close, indent, line)) {
+        break;
+      }
       this.next();
-    } else {
+    }
+    else {
       elts.push(elt);
     }
     this.eat(_.tokTypes.comma);
@@ -522,278 +612,326 @@
   this.popCx();
   if (!this.eat(close)) {
     // If there is no closing brace, make the node span to the start
-    // of the next token (this is useful for Tern)
+    // of the next token (this is useful for Tern).
     this.last.end = this.tok.start;
-    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
+    if (this.options.locations) {
+      this.last.loc.end = this.tok.loc.start;
+    }
   }
   return elts;
 };
 
 },{"..":1,"./parseutil":4,"./state":5}],3:[function(_dereq_,module,exports){
-// Acorn: Loose parser
-//
-// This module provides an alternative parser (`parse_dammit`) that
-// exposes that same interface as `parse`, but will try to parse
-// anything as JavaScript, repairing syntax error the best it can.
-// There are circumstances in which it will raise an error and give
-// up, but they are very rare. The resulting AST will be a mostly
-// valid JavaScript AST (as per the [Mozilla parser API][api], except
-// that:
-//
-// - Return outside functions is allowed
-//
-// - Label consistency (no conflicts, break only to existing labels)
-//   is not enforced.
-//
-// - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
-//   the parser got too confused to return anything meaningful.
-//
-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
-//
-// The expected use for this is to *first* try `acorn.parse`, and only
-// if that fails switch to `parse_dammit`. The loose parser might
-// parse badly indented code incorrectly, so **don't** use it as
-// your default parser.
-//
-// Quite a lot of acorn.js is duplicated here. The alternative was to
-// add a *lot* of extra cruft to that file, making it less readable
-// and slower. Copying and editing the code allowed me to make
-// invasive changes and simplifications without creating a complicated
-// tangle.
-
-"use strict";
-
-exports.__esModule = true;
-exports.parse_dammit = parse_dammit;
-
-function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
-
-var _ = _dereq_("..");
-
-var acorn = _interopRequireWildcard(_);
-
-var _state = _dereq_("./state");
-
-_dereq_("./tokenize");
-
-_dereq_("./statement");
-
-_dereq_("./expression");
-
-exports.LooseParser = _state.LooseParser;
-exports.pluginsLoose = _state.pluginsLoose;
-
-acorn.defaultOptions.tabSize = 4;
-
-function parse_dammit(input, options) {
-  var p = new _state.LooseParser(input, options);
-  p.next();
-  return p.parseTopLevel();
-}
-
-acorn.parse_dammit = parse_dammit;
-acorn.LooseParser = _state.LooseParser;
-acorn.pluginsLoose = _state.pluginsLoose;
-
-},{"..":1,"./expression":2,"./state":5,"./statement":6,"./tokenize":7}],4:[function(_dereq_,module,exports){
-"use strict";
-
-exports.__esModule = true;
-exports.isDummy = isDummy;
+  // Acorn: Loose parser
+  //
+  // This module provides an alternative parser (`parse_dammit`) that
+  // exposes that same interface as `parse`, but will try to parse
+  // anything as JavaScript, repairing syntax error the best it can.
+  // There are circumstances in which it will raise an error and give
+  // up, but they are very rare. The resulting AST will be a mostly
+  // valid JavaScript AST (as per the [Mozilla parser API][api], except
+  // that:
+  //
+  // - Return outside functions is allowed
+  //
+  // - Label consistency (no conflicts, break only to existing labels)
+  //   is not enforced.
+  //
+  // - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
+  //   the parser got too confused to return anything meaningful.
+  //
+  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
+  //
+  // The expected use for this is to *first* try `acorn.parse`, and only
+  // if that fails switch to `parse_dammit`. The loose parser might
+  // parse badly indented code incorrectly, so **don't** use it as
+  // your default parser.
+  //
+  // Quite a lot of acorn.js is duplicated here. The alternative was to
+  // add a *lot* of extra cruft to that file, making it less readable
+  // and slower. Copying and editing the code allowed me to make
+  // invasive changes and simplifications without creating a complicated
+  // tangle.
+  "use strict";
+
+  exports.__esModule = true;
+  exports.parse_dammit = parse_dammit;
+
+  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) {
+      return obj;
+  }
+  else {
+    var newObj = {}; if (obj != null) {
+      for (var key in obj) {
+        if (Object.prototype.hasOwnProperty.call(obj, key)) {
+          newObj[key] = obj[key];
+        }
+      }
+    } newObj["default"] = obj; return newObj;
+  }
+  }
 
-function isDummy(node) {
-  return node.name == "✖";
-}
+  var _ = _dereq_("..");
 
-},{}],5:[function(_dereq_,module,exports){
-"use strict";
+  var acorn = _interopRequireWildcard(_);
 
-exports.__esModule = true;
+  var _state = _dereq_("./state");
 
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+  _dereq_("./tokenize");
 
-var _ = _dereq_("..");
+  _dereq_("./statement");
 
-// Registered plugins
-var pluginsLoose = {};
+  _dereq_("./expression");
 
-exports.pluginsLoose = pluginsLoose;
+  exports.LooseParser = _state.LooseParser;
+  exports.pluginsLoose = _state.pluginsLoose;
 
-var LooseParser = (function () {
-  function LooseParser(input, options) {
-    _classCallCheck(this, LooseParser);
+  acorn.defaultOptions.tabSize = 4;
 
-    this.toks = _.tokenizer(input, options);
-    this.options = this.toks.options;
-    this.input = this.toks.input;
-    this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
-    if (this.options.locations) {
-      var here = this.toks.curPosition();
-      this.tok.loc = new _.SourceLocation(this.toks, here, here);
-    }
-    this.ahead = []; // Tokens ahead
-    this.context = []; // Indentation contexted
-    this.curIndent = 0;
-    this.curLineStart = 0;
-    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
-    // Load plugins
-    this.options.pluginsLoose = options.pluginsLoose || {};
-    this.loadPlugins(this.options.pluginsLoose);
+  function parse_dammit(input, options) {
+    var p = new _state.LooseParser(input, options);
+    p.next();
+    return p.parseTopLevel();
   }
 
-  LooseParser.prototype.startNode = function startNode() {
-    return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
-  };
+  acorn.parse_dammit = parse_dammit;
+  acorn.LooseParser = _state.LooseParser;
+  acorn.pluginsLoose = _state.pluginsLoose;
 
-  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
-    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
-  };
+},{"..":1,"./expression":2,"./state":5,"./statement":6,"./tokenize":7}],4:[function(_dereq_,module,exports){
+  "use strict";
 
-  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
-    if (this.options.locations) {
-      return new _.Node(this.toks, pos[0], pos[1]);
-    } else {
-      return new _.Node(this.toks, pos);
-    }
-  };
+  exports.__esModule = true;
+  exports.isDummy = isDummy;
 
-  LooseParser.prototype.finishNode = function finishNode(node, type) {
-    node.type = type;
-    node.end = this.last.end;
-    if (this.options.locations) node.loc.end = this.last.loc.end;
-    if (this.options.ranges) node.range[1] = this.last.end;
-    return node;
-  };
+  function isDummy(node) {
+    return node.name == "✖";
+  }
 
-  LooseParser.prototype.dummyNode = function dummyNode(type) {
-    var dummy = this.startNode();
-    dummy.type = type;
-    dummy.end = dummy.start;
-    if (this.options.locations) dummy.loc.end = dummy.loc.start;
-    if (this.options.ranges) dummy.range[1] = dummy.start;
-    this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
-    return dummy;
-  };
+},{}],5:[function(_dereq_,module,exports){
+  "use strict";
 
-  LooseParser.prototype.dummyIdent = function dummyIdent() {
-    var dummy = this.dummyNode("Identifier");
-    dummy.name = "✖";
-    return dummy;
-  };
+  exports.__esModule = true;
 
-  LooseParser.prototype.dummyString = function dummyString() {
-    var dummy = this.dummyNode("Literal");
-    dummy.value = dummy.raw = "✖";
-    return dummy;
-  };
+  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
+      throw new TypeError("Cannot call a class as a function");
+  }
+  }
 
-  LooseParser.prototype.eat = function eat(type) {
-    if (this.tok.type === type) {
-      this.next();
-      return true;
-    } else {
-      return false;
-    }
-  };
+  var _ = _dereq_("..");
 
-  LooseParser.prototype.isContextual = function isContextual(name) {
-    return this.tok.type === _.tokTypes.name && this.tok.value === name;
-  };
+  // Registered plugins.
+  var pluginsLoose = {};
 
-  LooseParser.prototype.eatContextual = function eatContextual(name) {
-    return this.tok.value === name && this.eat(_.tokTypes.name);
-  };
+  exports.pluginsLoose = pluginsLoose;
 
-  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
-    return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
-  };
+  var LooseParser = (function () {
+    function LooseParser(input, options) {
+      _classCallCheck(this, LooseParser);
 
-  LooseParser.prototype.semicolon = function semicolon() {
-    return this.eat(_.tokTypes.semi);
-  };
+      this.toks = _.tokenizer(input, options);
+      this.options = this.toks.options;
+      this.input = this.toks.input;
+      this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
+      if (this.options.locations) {
+        var here = this.toks.curPosition();
+        this.tok.loc = new _.SourceLocation(this.toks, here, here);
+      }
+      // Tokens ahead.
+      this.ahead = [];
+      // Indentation contexted.
+      this.context = [];
+      this.curIndent = 0;
+      this.curLineStart = 0;
+      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
+      // Load plugins.
+      this.options.pluginsLoose = options.pluginsLoose || {};
+      this.loadPlugins(this.options.pluginsLoose);
+    }
+
+    LooseParser.prototype.startNode = function startNode() {
+      return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
+    };
+
+    LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
+      return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
+    };
+
+    LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
+      if (this.options.locations) {
+        return new _.Node(this.toks, pos[0], pos[1]);
+      }
+      else {
+        return new _.Node(this.toks, pos);
+      }
+    };
 
-  LooseParser.prototype.expect = function expect(type) {
-    if (this.eat(type)) return true;
-    for (var i = 1; i <= 2; i++) {
-      if (this.lookAhead(i).type == type) {
-        for (var j = 0; j < i; j++) {
-          this.next();
-        }return true;
+    LooseParser.prototype.finishNode = function finishNode(node, type) {
+      node.type = type;
+      node.end = this.last.end;
+      if (this.options.locations) {
+        node.loc.end = this.last.loc.end;
       }
-    }
-  };
+      if (this.options.ranges) {
+        node.range[1] = this.last.end;
+      }
+      return node;
+    };
 
-  LooseParser.prototype.pushCx = function pushCx() {
-    this.context.push(this.curIndent);
-  };
+    LooseParser.prototype.dummyNode = function dummyNode(type) {
+      var dummy = this.startNode();
+      dummy.type = type;
+      dummy.end = dummy.start;
+      if (this.options.locations) {
+        dummy.loc.end = dummy.loc.start;
+      }
+      if (this.options.ranges) {
+        dummy.range[1] = dummy.start;
+      }
+      this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
+      return dummy;
+    };
+
+    LooseParser.prototype.dummyIdent = function dummyIdent() {
+      var dummy = this.dummyNode("Identifier");
+      dummy.name = "✖";
+      return dummy;
+    };
+
+    LooseParser.prototype.dummyString = function dummyString() {
+      var dummy = this.dummyNode("Literal");
+      dummy.value = dummy.raw = "✖";
+      return dummy;
+    };
 
-  LooseParser.prototype.popCx = function popCx() {
-    this.curIndent = this.context.pop();
-  };
+    LooseParser.prototype.eat = function eat(type) {
+      if (this.tok.type === type) {
+        this.next();
+        return true;
+      }
+      else {
+        return false;
+      }
+    };
 
-  LooseParser.prototype.lineEnd = function lineEnd(pos) {
-    while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) ++pos;
-    return pos;
-  };
+    LooseParser.prototype.isContextual = function isContextual(name) {
+      return this.tok.type === _.tokTypes.name && this.tok.value === name;
+    };
+
+    LooseParser.prototype.eatContextual = function eatContextual(name) {
+      return this.tok.value === name && this.eat(_.tokTypes.name);
+    };
+
+    LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
+      return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
+    };
+
+    LooseParser.prototype.semicolon = function semicolon() {
+      return this.eat(_.tokTypes.semi);
+    };
+
+    LooseParser.prototype.expect = function expect(type) {
+      if (this.eat(type)) {
+        return true;
+      }
+      for (var i = 1; i <= 2; i++) {
+        if (this.lookAhead(i).type == type) {
+          for (var j = 0; j < i; j++) {
+            this.next();
+          }return true;
+        }
+      }
+    };
 
-  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
-    for (var count = 0;; ++pos) {
-      var ch = this.input.charCodeAt(pos);
-      if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
-    }
-  };
+    LooseParser.prototype.pushCx = function pushCx() {
+      this.context.push(this.curIndent);
+    };
+
+    LooseParser.prototype.popCx = function popCx() {
+      this.curIndent = this.context.pop();
+    };
+
+    LooseParser.prototype.lineEnd = function lineEnd(pos) {
+      while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) {
+        ++pos;
+      }
+      return pos;
+    };
 
-  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
-    if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) return true;
-    return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
-  };
+    LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
+      for (var count = 0;; ++pos) {
+        var ch = this.input.charCodeAt(pos);
+        if (ch === 32) {
+          ++count;
+        }
+        else if (ch === 9) {
+          count += this.options.tabSize;
+        }
+        else {
+          return count;
+        }
+      }
+    };
 
-  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
-    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
-      var ch = this.input.charCodeAt(p);
-      if (ch !== 9 && ch !== 32) return false;
-    }
-    return true;
-  };
+    LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
+      if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) {
+        return true;
+      }
+      return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
+    };
 
-  LooseParser.prototype.extend = function extend(name, f) {
-    this[name] = f(this[name]);
-  };
+    LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
+      for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
+        var ch = this.input.charCodeAt(p);
+        if (ch !== 9 && ch !== 32) {
+          return false;
+        }
+      }
+      return true;
+    };
 
-  LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
-    for (var _name in pluginConfigs) {
-      var plugin = pluginsLoose[_name];
-      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
-      plugin(this, pluginConfigs[_name]);
-    }
-  };
+    LooseParser.prototype.extend = function extend(name, f) {
+      this[name] = f(this[name]);
+    };
+
+    LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
+      for (var _name in pluginConfigs) {
+        var plugin = pluginsLoose[_name];
+        if (!plugin) {
+          throw new Error("Plugin '" + _name + "' not found");
+        }
+        plugin(this, pluginConfigs[_name]);
+      }
+    };
 
-  return LooseParser;
-})();
+    return LooseParser;
+  })();
 
-exports.LooseParser = LooseParser;
+  exports.LooseParser = LooseParser;
 
 },{"..":1}],6:[function(_dereq_,module,exports){
-"use strict";
+  "use strict";
 
-var _state = _dereq_("./state");
+  var _state = _dereq_("./state");
 
-var _parseutil = _dereq_("./parseutil");
+  var _parseutil = _dereq_("./parseutil");
 
-var _ = _dereq_("..");
+  var _ = _dereq_("..");
 
-var lp = _state.LooseParser.prototype;
+  var lp = _state.LooseParser.prototype;
 
-lp.parseTopLevel = function () {
-  var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
-  node.body = [];
-  while (this.tok.type !== _.tokTypes.eof) node.body.push(this.parseStatement());
-  this.last = this.tok;
-  if (this.options.ecmaVersion >= 6) {
-    node.sourceType = this.options.sourceType;
-  }
-  return this.finishNode(node, "Program");
-};
+  lp.parseTopLevel = function () {
+    var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
+    node.body = [];
+    while (this.tok.type !== _.tokTypes.eof) {
+      node.body.push(this.parseStatement());
+    }
+    this.last = this.tok;
+    if (this.options.ecmaVersion >= 6) {
+      node.sourceType = this.options.sourceType;
+    }
+    return this.finishNode(node, "Program");
+  };
 
 lp.parseStatement = function () {
   var starttype = this.tok.type,
@@ -807,14 +945,15 @@
 
   switch (starttype) {
     case _.tokTypes._break:case _.tokTypes._continue:
-      this.next();
-      var isBreak = starttype === _.tokTypes._break;
-      if (this.semicolon() || this.canInsertSemicolon()) {
-        node.label = null;
-      } else {
-        node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
-        this.semicolon();
-      }
+        this.next();
+        var isBreak = starttype === _.tokTypes._break;
+        if (this.semicolon() || this.canInsertSemicolon()) {
+          node.label = null;
+        }
+        else {
+          node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
+          this.semicolon();
+        }
       return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
 
     case _.tokTypes._debugger:
@@ -833,7 +972,9 @@
       this.next();
       this.pushCx();
       this.expect(_.tokTypes.parenL);
-      if (this.tok.type === _.tokTypes.semi) return this.parseFor(node, null);
+      if (this.tok.type === _.tokTypes.semi) {
+        return this.parseFor(node, null);
+      }
       var isLet = this.toks.isLet();
       if (isLet || this.tok.type === _.tokTypes._var || this.tok.type === _.tokTypes._const) {
         var _init = this.parseVar(true, isLet ? "let" : this.tok.value);
@@ -843,7 +984,9 @@
         return this.parseFor(node, _init);
       }
       var init = this.parseExpression(true);
-      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
+      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) {
+        return this.parseForIn(node, this.toAssignable(init));
+      }
       return this.parseFor(node, init);
 
     case _.tokTypes._function:
@@ -859,7 +1002,10 @@
 
     case _.tokTypes._return:
       this.next();
-      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
+      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) {
+        node.argument = null;
+      }
+      else {
         node.argument = this.parseExpression();this.semicolon();
       }
       return this.finishNode(node, "ReturnStatement");
@@ -877,13 +1023,21 @@
       while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
         if (this.tok.type === _.tokTypes._case || this.tok.type === _.tokTypes._default) {
           var isCase = this.tok.type === _.tokTypes._case;
-          if (cur) this.finishNode(cur, "SwitchCase");
+          if (cur) {
+            this.finishNode(cur, "SwitchCase");
+          }
           node.cases.push(cur = this.startNode());
           cur.consequent = [];
           this.next();
-          if (isCase) cur.test = this.parseExpression();else cur.test = null;
+          if (isCase) {
+            cur.test = this.parseExpression();
+          }
+          else {
+            cur.test = null;
+          }
           this.expect(_.tokTypes.colon);
-        } else {
+        }
+        else {
           if (!cur) {
             node.cases.push(cur = this.startNode());
             cur.consequent = [];
@@ -892,7 +1046,9 @@
           cur.consequent.push(this.parseStatement());
         }
       }
-      if (cur) this.finishNode(cur, "SwitchCase");
+      if (cur) {
+        this.finishNode(cur, "SwitchCase");
+      }
       this.popCx();
       this.eat(_.tokTypes.braceR);
       return this.finishNode(node, "SwitchStatement");
@@ -917,7 +1073,9 @@
         node.handler = this.finishNode(clause, "CatchClause");
       }
       node.finalizer = this.eat(_.tokTypes._finally) ? this.parseBlock() : null;
-      if (!node.handler && !node.finalizer) return node.block;
+      if (!node.handler && !node.finalizer) {
+        return node.block;
+      }
       return this.finishNode(node, "TryStatement");
 
     case _.tokTypes._var:
@@ -956,13 +1114,17 @@
       var expr = this.parseExpression();
       if (_parseutil.isDummy(expr)) {
         this.next();
-        if (this.tok.type === _.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
+        if (this.tok.type === _.tokTypes.eof) {
+          return this.finishNode(node, "EmptyStatement");
+        }
         return this.parseStatement();
-      } else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
+      }
+      else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
         node.body = this.parseStatement();
         node.label = expr;
         return this.finishNode(node, "LabeledStatement");
-      } else {
+      }
+      else {
         node.expression = expr;
         this.semicolon();
         return this.finishNode(node, "ExpressionStatement");
@@ -977,7 +1139,9 @@
   var blockIndent = this.curIndent,
       line = this.curLineStart;
   node.body = [];
-  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
+  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
+    node.body.push(this.parseStatement());
+  }
   this.popCx();
   this.eat(_.tokTypes.braceR);
   return this.finishNode(node, "BlockStatement");
@@ -986,8 +1150,12 @@
 lp.parseFor = function (node, init) {
   node.init = init;
   node.test = node.update = null;
-  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) node.test = this.parseExpression();
-  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) node.update = this.parseExpression();
+  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) {
+    node.test = this.parseExpression();
+  }
+  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) {
+    node.update = this.parseExpression();
+  }
   this.popCx();
   this.expect(_.tokTypes.parenR);
   node.body = this.parseStatement();
@@ -1021,14 +1189,24 @@
     decl.id = this.dummyIdent();
     node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
   }
-  if (!noIn) this.semicolon();
+  if (!noIn) {
+    this.semicolon();
+  }
   return this.finishNode(node, "VariableDeclaration");
 };
 
 lp.parseClass = function (isStatement) {
   var node = this.startNode();
   this.next();
-  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
+  if (this.tok.type === _.tokTypes.name) {
+    node.id = this.parseIdent();
+  }
+  else if (isStatement) {
+    node.id = this.dummyIdent();
+  }
+  else {
+    node.id = null;
+  }
   node.superClass = this.eat(_.tokTypes._extends) ? this.parseExpression() : null;
   node.body = this.startNode();
   node.body.body = [];
@@ -1040,7 +1218,9 @@
     indent = this.curIndent;line = this.curLineStart;
   }
   while (!this.closes(_.tokTypes.braceR, indent, line)) {
-    if (this.semicolon()) continue;
+    if (this.semicolon()) {
+      continue;
+    }
     var method = this.startNode(),
         isGenerator = undefined;
     if (this.options.ecmaVersion >= 6) {
@@ -1049,23 +1229,28 @@
     }
     this.parsePropertyName(method);
     if (_parseutil.isDummy(method.key)) {
-      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
+      if (_parseutil.isDummy(this.parseMaybeAssign())) {
+        this.next();
+      }this.eat(_.tokTypes.comma);continue;
     }
     if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && this.tok.type != _.tokTypes.parenL && this.tok.type != _.tokTypes.braceL) {
       method["static"] = true;
       isGenerator = this.eat(_.tokTypes.star);
       this.parsePropertyName(method);
-    } else {
+    }
+    else {
       method["static"] = false;
     }
     if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _.tokTypes.parenL && this.tok.type !== _.tokTypes.braceL) {
       method.kind = method.key.name;
       this.parsePropertyName(method);
       method.value = this.parseMethod(false);
-    } else {
+    }
+    else {
       if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
         method.kind = "constructor";
-      } else {
+      }
+      else {
         method.kind = "method";
       }
       method.value = this.parseMethod(isGenerator);
@@ -1075,9 +1260,11 @@
   this.popCx();
   if (!this.eat(_.tokTypes.braceR)) {
     // If there is no closing brace, make the node span to the start
-    // of the next token (this is useful for Tern)
+    // of the next token (this is useful for Tern).
     this.last.end = this.tok.start;
-    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
+    if (this.options.locations) {
+      this.last.loc.end = this.tok.loc.start;
+    }
   }
   this.semicolon();
   this.finishNode(node.body, "ClassBody");
@@ -1089,7 +1276,12 @@
   if (this.options.ecmaVersion >= 6) {
     node.generator = this.eat(_.tokTypes.star);
   }
-  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
+  if (this.tok.type === _.tokTypes.name) {
+    node.id = this.parseIdent();
+  }
+  else if (isStatement) {
+    node.id = this.dummyIdent();
+  }
   node.params = this.parseFunctionParams();
   node.body = this.parseBlock();
   return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
@@ -1107,9 +1299,12 @@
     if (expr.id) {
       switch (expr.type) {
         case "FunctionExpression":
-          expr.type = "FunctionDeclaration";break;
+          expr.type = "FunctionDeclaration";
+          break;
+
         case "ClassExpression":
-          expr.type = "ClassDeclaration";break;
+          expr.type = "ClassDeclaration";
+          break;
       }
     }
     node.declaration = expr;
@@ -1120,7 +1315,8 @@
     node.declaration = this.parseStatement();
     node.specifiers = [];
     node.source = null;
-  } else {
+  }
+  else {
     node.declaration = null;
     node.specifiers = this.parseExportSpecifierList();
     node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
@@ -1136,7 +1332,8 @@
     node.specifiers = [];
     node.source = this.parseExprAtom();
     node.kind = '';
-  } else {
+  }
+  else {
     var elt = undefined;
     if (this.tok.type === _.tokTypes.name && this.tok.value !== "from") {
       elt = this.startNode();
@@ -1146,7 +1343,9 @@
     }
     node.specifiers = this.parseImportSpecifierList();
     node.source = this.eatContextual("from") && this.tok.type == _.tokTypes.string ? this.parseExprAtom() : this.dummyString();
-    if (elt) node.specifiers.unshift(elt);
+    if (elt) {
+      node.specifiers.unshift(elt);
+    }
   }
   this.semicolon();
   return this.finishNode(node, "ImportDeclaration");
@@ -1157,24 +1356,34 @@
   if (this.tok.type === _.tokTypes.star) {
     var elt = this.startNode();
     this.next();
-    if (this.eatContextual("as")) elt.local = this.parseIdent();
+    if (this.eatContextual("as")) {
+      elt.local = this.parseIdent();
+    }
     elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
-  } else {
+  }
+  else {
     var indent = this.curIndent,
         line = this.curLineStart,
         continuedLine = this.nextLineStart;
     this.pushCx();
     this.eat(_.tokTypes.braceL);
-    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
+    if (this.curLineStart > continuedLine) {
+      continuedLine = this.curLineStart;
+    }
     while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
       var elt = this.startNode();
       if (this.eat(_.tokTypes.star)) {
         elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
         this.finishNode(elt, "ImportNamespaceSpecifier");
-      } else {
-        if (this.isContextual("from")) break;
+      }
+      else {
+        if (this.isContextual("from")) {
+          break;
+        }
         elt.imported = this.parseIdent();
-        if (_parseutil.isDummy(elt.imported)) break;
+        if (_parseutil.isDummy(elt.imported)) {
+          break;
+        }
         elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
         this.finishNode(elt, "ImportSpecifier");
       }
@@ -1194,12 +1403,18 @@
       continuedLine = this.nextLineStart;
   this.pushCx();
   this.eat(_.tokTypes.braceL);
-  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
+  if (this.curLineStart > continuedLine) {
+    continuedLine = this.curLineStart;
+  }
   while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
-    if (this.isContextual("from")) break;
+    if (this.isContextual("from")) {
+      break;
+    }
     var elt = this.startNode();
     elt.local = this.parseIdent();
-    if (_parseutil.isDummy(elt.local)) break;
+    if (_parseutil.isDummy(elt.local)) {
+      break;
+    }
     elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
     this.finishNode(elt, "ExportSpecifier");
     elts.push(elt);
@@ -1211,30 +1426,35 @@
 };
 
 },{"..":1,"./parseutil":4,"./state":5}],7:[function(_dereq_,module,exports){
-"use strict";
+  "use strict";
 
-var _ = _dereq_("..");
+  var _ = _dereq_("..");
 
-var _state = _dereq_("./state");
+  var _state = _dereq_("./state");
 
-var lp = _state.LooseParser.prototype;
+  var lp = _state.LooseParser.prototype;
 
-function isSpace(ch) {
-  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
-}
+  function isSpace(ch) {
+    return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
+  }
 
-lp.next = function () {
-  this.last = this.tok;
-  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();
-
-  if (this.tok.start >= this.nextLineStart) {
-    while (this.tok.start >= this.nextLineStart) {
-      this.curLineStart = this.nextLineStart;
-      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
+  lp.next = function () {
+    this.last = this.tok;
+    if (this.ahead.length) {
+      this.tok = this.ahead.shift();
     }
-    this.curIndent = this.indentationAfter(this.curLineStart);
-  }
-};
+    else {
+      this.tok = this.readToken();
+    }
+
+    if (this.tok.start >= this.nextLineStart) {
+      while (this.tok.start >= this.nextLineStart) {
+        this.curLineStart = this.nextLineStart;
+        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
+      }
+      this.curIndent = this.indentationAfter(this.curLineStart);
+    }
+  };
 
 lp.readToken = function () {
   for (;;) {
@@ -1245,10 +1465,13 @@
         this.toks.type = _.tokTypes.ellipsis;
       }
       return new _.Token(this.toks);
-    } catch (e) {
-      if (!(e instanceof SyntaxError)) throw e;
+    }
+    catch (e) {
+      if (!(e instanceof SyntaxError)) {
+        throw e;
+      }
 
-      // Try to skip some text, based on the error message, and then continue
+      // Try to skip some text, based on the error message, and then continue.
       var msg = e.message,
           pos = e.raisedAt,
           replace = true;
@@ -1256,38 +1479,57 @@
         pos = this.lineEnd(e.pos + 1);
         if (/string/.test(msg)) {
           replace = { start: e.pos, end: pos, type: _.tokTypes.string, value: this.input.slice(e.pos + 1, pos) };
-        } else if (/regular expr/i.test(msg)) {
+        }
+        else if (/regular expr/i.test(msg)) {
           var re = this.input.slice(e.pos, pos);
           try {
             re = new RegExp(re);
-          } catch (e) {}
+          }
+          catch (e) {
+
+          }
           replace = { start: e.pos, end: pos, type: _.tokTypes.regexp, value: re };
-        } else if (/template/.test(msg)) {
+        }
+        else if (/template/.test(msg)) {
           replace = { start: e.pos, end: pos,
             type: _.tokTypes.template,
             value: this.input.slice(e.pos, pos) };
-        } else {
+        }
+        else {
           replace = false;
         }
-      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
-        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
-      } else if (/character escape|expected hexadecimal/i.test(msg)) {
+      }
+      else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
+        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) {
+          ++pos;
+        }
+      }
+      else if (/character escape|expected hexadecimal/i.test(msg)) {
         while (pos < this.input.length) {
           var ch = this.input.charCodeAt(pos++);
-          if (ch === 34 || ch === 39 || _.isNewLine(ch)) break;
+          if (ch === 34 || ch === 39 || _.isNewLine(ch)) {
+            break;
+          }
         }
-      } else if (/unexpected character/i.test(msg)) {
+      }
+      else if (/unexpected character/i.test(msg)) {
         pos++;
         replace = false;
-      } else if (/regular expression/i.test(msg)) {
+      }
+      else if (/regular expression/i.test(msg)) {
         replace = true;
-      } else {
+      }
+      else {
         throw e;
       }
       this.resetTo(pos);
-      if (replace === true) replace = { start: pos, end: pos, type: _.tokTypes.name, value: "✖" };
+      if (replace === true) {
+        replace = start: pos, end: pos, type: _.tokTypes.name, value: "✖"
+      };
       if (replace) {
-        if (this.options.locations) replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
+        if (this.options.locations) {
+          replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
+        }
         return replace;
       }
     }
@@ -1311,9 +1553,12 @@
 };
 
 lp.lookAhead = function (n) {
-  while (n > this.ahead.length) this.ahead.push(this.readToken());
+  while (n > this.ahead.length) {
+    this.ahead.push(this.readToken());
+  }
   return this.ahead[n - 1];
 };
 
-},{"..":1,"./state":5}]},{},[3])(3)
-});
\ No newline at end of file
+},{"..":1,"./state":5}]
+},{},[3])(3)
+});

--- themes/c4m/kapablo/build/node_modules/acorn/src/bin/acorn.js
+++ PHP_CodeSniffer
@@ -1,4 +1,8 @@
-#!/usr/bin/env node
+/**
+ * @file
+ */
+
+#! / usr / bin / env node
 
 import {basename} from "path"
 import {readFileSync as readFile} from "fs"
@@ -16,45 +20,87 @@
 
 for (let i = 2; i < process.argv.length; ++i) {
   const arg = process.argv[i]
-  if ((arg == "-" || arg[0] != "-") && !infile) infile = arg
-  else if (arg == "--" && !infile && i + 2 == process.argv.length) forceFile = infile = process.argv[++i]
-  else if (arg == "--ecma3") options.ecmaVersion = 3
-  else if (arg == "--ecma5") options.ecmaVersion = 5
-  else if (arg == "--ecma6") options.ecmaVersion = 6
-  else if (arg == "--ecma7") options.ecmaVersion = 7
-  else if (arg == "--locations") options.locations = true
-  else if (arg == "--allow-hash-bang") options.allowHashBang = true
-  else if (arg == "--silent") silent = true
-  else if (arg == "--compact") compact = true
-  else if (arg == "--help") help(0)
-  else if (arg == "--tokenize") tokenize = true
-  else if (arg == "--module") options.sourceType = 'module'
-  else help(1)
+  if ((arg == "-" || arg[0] != "-") && !infile) {
+    infile = arg
+    else if (arg == "--" && !infile && i + 2 == process.argv.length) {
+      forceFile = infile = process.argv[++i]
+      else if (arg == "--ecma3") {
+        options.ecmaVersion = 3
+        else if (arg == "--ecma5") {
+          options.ecmaVersion = 5
+          else if (arg == "--ecma6") {
+            options.ecmaVersion = 6
+            else if (arg == "--ecma7") {
+              options.ecmaVersion = 7
+              else if (arg == "--locations") {
+                options.locations = true
+                else if (arg == "--allow-hash-bang") {
+                  options.allowHashBang = true
+                  else if (arg == "--silent") {
+                    silent = true
+                    else if (arg == "--compact") {
+                      compact = true
+                      else if (arg == "--help") {
+                        help(0)
+                        else if (arg == "--tokenize") {
+                          tokenize = true
+                          else if (arg == "--module") {
+                            options.sourceType = 'module'
+                            else {
+                              help(1)
+                            }
+                          }
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
 }
 
 function run(code) {
   let result
   if (!tokenize) {
-    try { result = acorn.parse(code, options) }
-    catch(e) { console.error(e.message); process.exit(1) }
-  } else {
+    try {
+      result = acorn.parse(code, options)
+    }
+    catch (e) {
+      console.error(e.message); process.exit(1)
+    }
+  }
+  else {
     result = []
     let tokenizer = acorn.tokenizer(code, options), token
     while (true) {
-      try { token = tokenizer.getToken() }
-      catch(e) { console.error(e.message); process.exit(1) }
+      try {
+        token = tokenizer.getToken()
+      }
+      catch (e) {
+        console.error(e.message); process.exit(1)
+      }
       result.push(token)
-      if (token.type == acorn.tokTypes.eof) break
+      if (token.type == acorn.tokTypes.eof) {
+        break
+      }
     }
   }
-  if (!silent) console.log(JSON.stringify(result, null, compact ? null : 2))
+  if (!silent) {
+    console.log(JSON.stringify(result, null, compact ? null : 2))
+  }
 }
 
 if (forceFile || infile && infile != "-") {
   run(readFile(infile, "utf8"))
-} else {
+}
+else {
   let code = ""
   process.stdin.resume()
-  process.stdin.on("data", chunk => code += chunk)
-  process.stdin.on("end", () => run(code))
+  process.stdin.on("data", chunk = > code += chunk)
+  process.stdin.on("end", () = > run(code))
 }

--- themes/c4m/kapablo/build/node_modules/acorn/src/expression.js
+++ PHP_CodeSniffer
@@ -1,5 +1,9 @@
-// A recursive descent parser operates by defining functions for all
-// syntactic elements, and recursively calling those, each function
+/**
+ * @file
+ * A recursive descent parser operates by defining functions for all.
+ */
+
+// Syntactic elements, and recursively calling those, each function
 // advancing the input stream and returning an AST node. Precedence
 // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
 // instead of `(!x)[1]` is handled by the fact that the parser
@@ -15,7 +19,6 @@
 // precedence levels that JavaScript defines.
 //
 // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
-
 import {types as tt} from "./tokentype"
 import {Parser} from "./state"
 
@@ -25,21 +28,26 @@
 // Object/class getters and setters are not allowed to clash —
 // either with each other or with an init property — and in
 // strict mode, init properties are also not allowed to be repeated.
-
 pp.checkPropClash = function(prop, propHash) {
-  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
+  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
     return
-  let {key} = prop, name
+    let key
+  } = prop, name
   switch (key.type) {
-  case "Identifier": name = key.name; break
-  case "Literal": name = String(key.value); break
-  default: return
+    case "Identifier": name = key.name;
+      break
+    case "Literal": name = String(key.value);
+      break
+    default:
+      return
   }
   let {kind} = prop
   if (this.options.ecmaVersion >= 6) {
     if (name === "__proto__" && kind === "init") {
-      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property")
-      propHash.proto = true
+      if (propHash.proto) {
+        this.raiseRecoverable(key.start, "Redefinition of __proto__ property")
+        propHash.proto = true
+      }
     }
     return
   }
@@ -47,9 +55,11 @@
   let other = propHash[name]
   if (other) {
     let isGetSet = kind !== "init"
-    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
+    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) {
       this.raiseRecoverable(key.start, "Redefinition of property")
-  } else {
+    }
+  }
+  else {
     other = propHash[name] = {
       init: false,
       get: false,
@@ -59,89 +69,100 @@
   other[kind] = true
 }
 
-// ### Expression parsing
-
+// ### Expression parsing.
 // These nest, from the most general expression type at the top to
 // 'atomic', nondivisible expression types at the bottom. Most of
 // the functions will simply let the function(s) below them parse,
 // and, *if* the syntactic construct they handle is present, wrap
 // the AST node that the inner parser gave them in another node.
-
 // Parse a full expression. The optional arguments are used to
 // forbid the `in` operator (in for loops initalization expressions)
 // and provide reference for storing '=' operator inside shorthand
 // property assignment in contexts where both object expression
 // and object pattern might appear (so it's possible to raise
 // delayed syntax error at correct position).
-
 pp.parseExpression = function(noIn, refDestructuringErrors) {
   let startPos = this.start, startLoc = this.startLoc
   let expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
   if (this.type === tt.comma) {
     let node = this.startNodeAt(startPos, startLoc)
     node.expressions = [expr]
-    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))
-    return this.finishNode(node, "SequenceExpression")
+    while (this.eat(tt.comma)) {
+      node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))
+      return this.finishNode(node, "SequenceExpression")
+    }
   }
   return expr
 }
 
 // Parse an assignment expression. This includes applications of
 // operators like `+=`.
-
 pp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
-  if (this.inGenerator && this.isContextual("yield")) return this.parseYield()
+  if (this.inGenerator && this.isContextual("yield")) {
+    return this.parseYield()
 
-  let validateDestructuring = false
-  if (!refDestructuringErrors) {
-    refDestructuringErrors = {shorthandAssign: 0, trailingComma: 0}
-    validateDestructuring = true
+    let validateDestructuring = false
+    if (!refDestructuringErrors) {
+      refDestructuringErrors = {shorthandAssign: 0, trailingComma: 0}
+      validateDestructuring = true
+    }
   }
   let startPos = this.start, startLoc = this.startLoc
-  if (this.type == tt.parenL || this.type == tt.name)
+  if (this.type == tt.parenL || this.type == tt.name) {
     this.potentialArrowAt = this.start
-  let left = this.parseMaybeConditional(noIn, refDestructuringErrors)
-  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
-  if (this.type.isAssign) {
-    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true)
-    let node = this.startNodeAt(startPos, startLoc)
-    node.operator = this.value
-    node.left = this.type === tt.eq ? this.toAssignable(left) : left
-    refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly
-    this.checkLVal(left)
-    this.next()
-    node.right = this.parseMaybeAssign(noIn)
-    return this.finishNode(node, "AssignmentExpression")
-  } else {
-    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true)
+    let left = this.parseMaybeConditional(noIn, refDestructuringErrors)
+    if (afterLeftParse) {
+      left = afterLeftParse.call(this, left, startPos, startLoc)
+      if (this.type.isAssign) {
+        if (validateDestructuring) {
+          this.checkPatternErrors(refDestructuringErrors, true)
+          let node = this.startNodeAt(startPos, startLoc)
+          node.operator = this.value
+          node.left = this.type === tt.eq ? this.toAssignable(left) : left
+          // Reset because shorthand default was used correctly.
+          refDestructuringErrors.shorthandAssign = 0
+          this.checkLVal(left)
+          this.next()
+          node.right = this.parseMaybeAssign(noIn)
+          return this.finishNode(node, "AssignmentExpression")
+        }
+      }
+      else {
+        if (validateDestructuring) {
+          this.checkExpressionErrors(refDestructuringErrors, true)
+        }
+      }
+    }
   }
   return left
 }
 
 // Parse a ternary conditional (`?:`) operator.
-
 pp.parseMaybeConditional = function(noIn, refDestructuringErrors) {
   let startPos = this.start, startLoc = this.startLoc
   let expr = this.parseExprOps(noIn, refDestructuringErrors)
-  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
-  if (this.eat(tt.question)) {
-    let node = this.startNodeAt(startPos, startLoc)
-    node.test = expr
-    node.consequent = this.parseMaybeAssign()
-    this.expect(tt.colon)
-    node.alternate = this.parseMaybeAssign(noIn)
-    return this.finishNode(node, "ConditionalExpression")
+  if (this.checkExpressionErrors(refDestructuringErrors)) {
+    return expr
+    if (this.eat(tt.question)) {
+      let node = this.startNodeAt(startPos, startLoc)
+      node.test = expr
+      node.consequent = this.parseMaybeAssign()
+      this.expect(tt.colon)
+      node.alternate = this.parseMaybeAssign(noIn)
+      return this.finishNode(node, "ConditionalExpression")
+    }
   }
   return expr
 }
 
 // Start the precedence parser.
-
 pp.parseExprOps = function(noIn, refDestructuringErrors) {
   let startPos = this.start, startLoc = this.startLoc
   let expr = this.parseMaybeUnary(refDestructuringErrors, false)
-  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
-  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
+  if (this.checkExpressionErrors(refDestructuringErrors)) {
+    return expr
+    return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
+  }
 }
 
 // Parse binary operators with the operator precedence parsing
@@ -149,7 +170,6 @@
 // `minPrec` provides context that allows the function to stop and
 // defer further parser to one of its callers when it encounters an
 // operator that has a lower precedence than the set it is parsing.
-
 pp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
   let prec = this.type.binop
   if (prec != null && (!noIn || this.type !== tt._in)) {
@@ -175,7 +195,6 @@
 }
 
 // Parse unary operators, both prefix and postfix.
-
 pp.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
   let startPos = this.start, startLoc = this.startLoc, expr
   if (this.type.prefix) {
@@ -185,40 +204,51 @@
     this.next()
     node.argument = this.parseMaybeUnary(null, true)
     this.checkExpressionErrors(refDestructuringErrors, true)
-    if (update) this.checkLVal(node.argument)
-    else if (this.strict && node.operator === "delete" &&
-             node.argument.type === "Identifier")
-      this.raiseRecoverable(node.start, "Deleting local variable in strict mode")
-    else sawUnary = true
-    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
-  } else {
+    if (update) {
+      this.checkLVal(node.argument)
+      else if (this.strict && node.operator === "delete" &&
+             node.argument.type === "Identifier") {
+        this.raiseRecoverable(node.start, "Deleting local variable in strict mode")
+        else {
+          sawUnary = true
+          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
+        }
+      }
+    }
+  }
+  else {
     expr = this.parseExprSubscripts(refDestructuringErrors)
-    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
-    while (this.type.postfix && !this.canInsertSemicolon()) {
-      let node = this.startNodeAt(startPos, startLoc)
-      node.operator = this.value
-      node.prefix = false
-      node.argument = expr
-      this.checkLVal(expr)
-      this.next()
-      expr = this.finishNode(node, "UpdateExpression")
+    if (this.checkExpressionErrors(refDestructuringErrors)) {
+      return expr
+      while (this.type.postfix && !this.canInsertSemicolon()) {
+        let node = this.startNodeAt(startPos, startLoc)
+        node.operator = this.value
+        node.prefix = false
+        node.argument = expr
+        this.checkLVal(expr)
+        this.next()
+        expr = this.finishNode(node, "UpdateExpression")
+      }
     }
   }
 
-  if (!sawUnary && this.eat(tt.starstar))
+  if (!sawUnary && this.eat(tt.starstar)) {
     return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false)
-  else
-    return expr
+    else {
+      return expr
+    }
+  }
 }
 
 // Parse call, dot, and `[]`-subscript expressions.
-
 pp.parseExprSubscripts = function(refDestructuringErrors) {
   let startPos = this.start, startLoc = this.startLoc
   let expr = this.parseExprAtom(refDestructuringErrors)
   let skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
-  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
-  return this.parseSubscripts(expr, startPos, startLoc)
+  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
+    return expr
+    return this.parseSubscripts(expr, startPos, startLoc)
+  }
 }
 
 pp.parseSubscripts = function(base, startPos, startLoc, noCalls) {
@@ -229,24 +259,28 @@
       node.property = this.parseIdent(true)
       node.computed = false
       base = this.finishNode(node, "MemberExpression")
-    } else if (this.eat(tt.bracketL)) {
+    }
+    else if (this.eat(tt.bracketL)) {
       let node = this.startNodeAt(startPos, startLoc)
       node.object = base
       node.property = this.parseExpression()
       node.computed = true
       this.expect(tt.bracketR)
       base = this.finishNode(node, "MemberExpression")
-    } else if (!noCalls && this.eat(tt.parenL)) {
+    }
+    else if (!noCalls && this.eat(tt.parenL)) {
       let node = this.startNodeAt(startPos, startLoc)
       node.callee = base
       node.arguments = this.parseExprList(tt.parenR, false)
       base = this.finishNode(node, "CallExpression")
-    } else if (this.type === tt.backQuote) {
+    }
+    else if (this.type === tt.backQuote) {
       let node = this.startNodeAt(startPos, startLoc)
       node.tag = base
       node.quasi = this.parseTemplate()
       base = this.finishNode(node, "TaggedTemplateExpression")
-    } else {
+    }
+    else {
       return base
     }
   }
@@ -256,71 +290,72 @@
 // expression, an expression started by a keyword like `function` or
 // `new`, or an expression wrapped in punctuation like `()`, `[]`,
 // or `{}`.
-
 pp.parseExprAtom = function(refDestructuringErrors) {
   let node, canBeArrow = this.potentialArrowAt == this.start
   switch (this.type) {
-  case tt._super:
-    if (!this.inFunction)
-      this.raise(this.start, "'super' outside of function or class")
-
-  case tt._this:
-    let type = this.type === tt._this ? "ThisExpression" : "Super"
-    node = this.startNode()
-    this.next()
-    return this.finishNode(node, type)
-
-  case tt.name:
-    let startPos = this.start, startLoc = this.startLoc
-    let id = this.parseIdent(this.type !== tt.name)
-    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))
-      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])
-    return id
-
-  case tt.regexp:
-    let value = this.value
-    node = this.parseLiteral(value.value)
-    node.regex = {pattern: value.pattern, flags: value.flags}
-    return node
-
-  case tt.num: case tt.string:
-    return this.parseLiteral(this.value)
-
-  case tt._null: case tt._true: case tt._false:
-    node = this.startNode()
-    node.value = this.type === tt._null ? null : this.type === tt._true
-    node.raw = this.type.keyword
-    this.next()
-    return this.finishNode(node, "Literal")
+    case tt._super:
+      if (!this.inFunction) {
+        this.raise(this.start, "'super' outside of function or class")
+
+        case tt._this:
+          let type = this.type === tt._this ? "ThisExpression" : "Super"
+          node = this.startNode()
+          this.next()
+          return;
+
+      } this.finishNode(node, type)
+
+      case tt.name:
+        let startPos = this.start, startLoc = this.startLoc
+        let id = this.parseIdent(this.type !== tt.name)
+        if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
+        } this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])
+      return id
+
+    case tt.regexp:
+      let value = this.value
+      node = this.parseLiteral(value.value)
+      node.regex = {pattern: value.pattern, flags: value.flags}
+      return node
+
+    case tt.num: case tt.string:
+      return this.parseLiteral(this.value)
+
+    case tt._null: case tt._true: case tt._false:
+          node = this.startNode()
+          node.value = this.type === tt._null ? null : this.type === tt._true
+          node.raw = this.type.keyword
+          this.next()
+      return this.finishNode(node, "Literal")
 
-  case tt.parenL:
-    return this.parseParenAndDistinguishExpression(canBeArrow)
+    case tt.parenL:
+      return this.parseParenAndDistinguishExpression(canBeArrow)
 
-  case tt.bracketL:
-    node = this.startNode()
-    this.next()
-    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
-    return this.finishNode(node, "ArrayExpression")
+    case tt.bracketL:
+      node = this.startNode()
+      this.next()
+      node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
+      return this.finishNode(node, "ArrayExpression")
 
-  case tt.braceL:
-    return this.parseObj(false, refDestructuringErrors)
+    case tt.braceL:
+      return this.parseObj(false, refDestructuringErrors)
 
-  case tt._function:
-    node = this.startNode()
-    this.next()
-    return this.parseFunction(node, false)
+    case tt._function:
+      node = this.startNode()
+      this.next()
+      return this.parseFunction(node, false)
 
-  case tt._class:
-    return this.parseClass(this.startNode(), false)
+    case tt._class:
+      return this.parseClass(this.startNode(), false)
 
-  case tt._new:
-    return this.parseNew()
+    case tt._new:
+      return this.parseNew()
 
-  case tt.backQuote:
-    return this.parseTemplate()
+    case tt.backQuote:
+      return this.parseTemplate()
 
-  default:
-    this.unexpected()
+    default:
+      this.unexpected()
   }
 }
 
@@ -353,7 +388,8 @@
         spreadStart = this.start
         exprList.push(this.parseParenItem(this.parseRest()))
         break
-      } else {
+      }
+      else {
         if (this.type === tt.parenL && !innerParenStart) {
           innerParenStart = this.start
         }
@@ -365,22 +401,30 @@
 
     if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
       this.checkPatternErrors(refDestructuringErrors, true)
-      if (innerParenStart) this.unexpected(innerParenStart)
-      return this.parseParenArrowList(startPos, startLoc, exprList)
+      if (innerParenStart) {
+        this.unexpected(innerParenStart)
+        return this.parseParenArrowList(startPos, startLoc, exprList)
+      }
     }
 
-    if (!exprList.length) this.unexpected(this.lastTokStart)
-    if (spreadStart) this.unexpected(spreadStart)
-    this.checkExpressionErrors(refDestructuringErrors, true)
-
-    if (exprList.length > 1) {
-      val = this.startNodeAt(innerStartPos, innerStartLoc)
-      val.expressions = exprList
-      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)
-    } else {
-      val = exprList[0]
+    if (!exprList.length) {
+      this.unexpected(this.lastTokStart)
+      if (spreadStart) {
+        this.unexpected(spreadStart)
+        this.checkExpressionErrors(refDestructuringErrors, true)
+
+        if (exprList.length > 1) {
+          val = this.startNodeAt(innerStartPos, innerStartLoc)
+          val.expressions = exprList
+          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)
+        }
+        else {
+          val = exprList[0]
+        }
+      }
     }
-  } else {
+  }
+  else {
     val = this.parseParenExpression()
   }
 
@@ -388,7 +432,8 @@
     let par = this.startNodeAt(startPos, startLoc)
     par.expression = val
     return this.finishNode(par, "ParenthesizedExpression")
-  } else {
+  }
+  else {
     return val
   }
 }
@@ -406,7 +451,6 @@
 // not without wrapping it in parentheses. Thus, it uses the noCalls
 // argument to parseSubscripts to prevent it from consuming the
 // argument list.
-
 const empty = []
 
 pp.parseNew = function() {
@@ -415,21 +459,26 @@
   if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
     node.meta = meta
     node.property = this.parseIdent(true)
-    if (node.property.name !== "target")
+    if (node.property.name !== "target") {
       this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target")
-    if (!this.inFunction)
-      this.raiseRecoverable(node.start, "new.target can only be used in functions")
-    return this.finishNode(node, "MetaProperty")
+      if (!this.inFunction) {
+        this.raiseRecoverable(node.start, "new.target can only be used in functions")
+        return this.finishNode(node, "MetaProperty")
+      }
+    }
   }
   let startPos = this.start, startLoc = this.startLoc
   node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
-  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)
-  else node.arguments = empty
-  return this.finishNode(node, "NewExpression")
+  if (this.eat(tt.parenL)) {
+    node.arguments = this.parseExprList(tt.parenR, false)
+    else {
+      node.arguments = empty
+      return this.finishNode(node, "NewExpression")
+    }
+  }
 }
 
 // Parse template expression.
-
 pp.parseTemplateElement = function() {
   let elem = this.startNode()
   elem.value = {
@@ -458,7 +507,6 @@
 }
 
 // Parse an object literal or binding pattern.
-
 pp.parseObj = function(isPattern, refDestructuringErrors) {
   let node = this.startNode(), first = true, propHash = {}
   node.properties = []
@@ -466,19 +514,25 @@
   while (!this.eat(tt.braceR)) {
     if (!first) {
       this.expect(tt.comma)
-      if (this.afterTrailingComma(tt.braceR)) break
-    } else first = false
+      if (this.afterTrailingComma(tt.braceR)) {
+        break
+      }
+    }
+    else {
+      first = false
 
-    let prop = this.startNode(), isGenerator, startPos, startLoc
-    if (this.options.ecmaVersion >= 6) {
-      prop.method = false
-      prop.shorthand = false
-      if (isPattern || refDestructuringErrors) {
-        startPos = this.start
-        startLoc = this.startLoc
+      let prop = this.startNode(), isGenerator, startPos, startLoc
+      if (this.options.ecmaVersion >= 6) {
+        prop.method = false
+        prop.shorthand = false
+        if (isPattern || refDestructuringErrors) {
+          startPos = this.start
+          startLoc = this.startLoc
+        }
+        if (!isPattern) {
+          isGenerator = this.eat(tt.star)
+        }
       }
-      if (!isPattern)
-        isGenerator = this.eat(tt.star)
     }
     this.parsePropertyName(prop)
     this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)
@@ -490,47 +544,64 @@
 
 pp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
   if (this.eat(tt.colon)) {
-      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)
+    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)
       prop.kind = "init"
-    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
-      if (isPattern) this.unexpected()
+  }
+  else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
+    if (isPattern) {
+      this.unexpected()
       prop.kind = "init"
       prop.method = true
       prop.value = this.parseMethod(isGenerator)
-    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
+    }
+  }
+  else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                (prop.key.name === "get" || prop.key.name === "set") &&
                (this.type != tt.comma && this.type != tt.braceR)) {
-      if (isGenerator || isPattern) this.unexpected()
+    if (isGenerator || isPattern) {
+      this.unexpected()
       prop.kind = prop.key.name
       this.parsePropertyName(prop)
       prop.value = this.parseMethod(false)
       let paramCount = prop.kind === "get" ? 0 : 1
       if (prop.value.params.length !== paramCount) {
         let start = prop.value.start
-        if (prop.kind === "get")
+        if (prop.kind === "get") {
           this.raiseRecoverable(start, "getter should have no params")
-        else
-          this.raiseRecoverable(start, "setter should have exactly one param")
+          else {
+            this.raiseRecoverable(start, "setter should have exactly one param")
+          }
+        }
       }
-      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
-        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params")
-    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
-      prop.kind = "init"
+    }
+    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
+      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params")
+    }
+  }
+  else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
+    prop.kind = "init"
       if (isPattern) {
-        if (this.keywords.test(prop.key.name) ||
+      if (this.keywords.test(prop.key.name) ||
             (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||
-            (this.inGenerator && prop.key.name == "yield"))
-          this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name)
+            (this.inGenerator && prop.key.name == "yield")) {
+        this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name)
         prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
-      } else if (this.type === tt.eq && refDestructuringErrors) {
-        if (!refDestructuringErrors.shorthandAssign)
+      }
+      }
+      else if (this.type === tt.eq && refDestructuringErrors) {
+        if (!refDestructuringErrors.shorthandAssign) {
           refDestructuringErrors.shorthandAssign = this.start
-        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
-      } else {
+          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
+        }
+      }
+      else {
         prop.value = prop.key
       }
       prop.shorthand = true
-    } else this.unexpected()
+  }
+  else {
+    this.unexpected()
+  }
 }
 
 pp.parsePropertyName = function(prop) {
@@ -540,7 +611,8 @@
       prop.key = this.parseMaybeAssign()
       this.expect(tt.bracketR)
       return prop.key
-    } else {
+    }
+    else {
       prop.computed = false
     }
   }
@@ -548,7 +620,6 @@
 }
 
 // Initialize empty function node.
-
 pp.initFunction = function(node) {
   node.id = null
   if (this.options.ecmaVersion >= 6) {
@@ -558,22 +629,21 @@
 }
 
 // Parse object or class method.
-
 pp.parseMethod = function(isGenerator) {
   let node = this.startNode(), oldInGen = this.inGenerator
   this.inGenerator = isGenerator
   this.initFunction(node)
   this.expect(tt.parenL)
   node.params = this.parseBindingList(tt.parenR, false, false)
-  if (this.options.ecmaVersion >= 6)
+  if (this.options.ecmaVersion >= 6) {
     node.generator = isGenerator
-  this.parseFunctionBody(node, false)
-  this.inGenerator = oldInGen
-  return this.finishNode(node, "FunctionExpression")
+    this.parseFunctionBody(node, false)
+    this.inGenerator = oldInGen
+    return this.finishNode(node, "FunctionExpression")
+  }
 }
 
 // Parse arrow function expression with given parameters.
-
 pp.parseArrowExpression = function(node, params) {
   let oldInGen = this.inGenerator
   this.inGenerator = false
@@ -585,14 +655,14 @@
 }
 
 // Parse function body and check parameters.
-
 pp.parseFunctionBody = function(node, isArrowFunction) {
   let isExpression = isArrowFunction && this.type !== tt.braceL
 
   if (isExpression) {
     node.body = this.parseMaybeAssign()
     node.expression = true
-  } else {
+  }
+  else {
     // Start a new scope with regard to labels and the `inFunction`
     // flag (restore them to their old value afterwards).
     let oldInFunc = this.inFunction, oldLabels = this.labels
@@ -608,22 +678,24 @@
   if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
     let oldStrict = this.strict
     this.strict = true
-    if (node.id)
+    if (node.id) {
       this.checkLVal(node.id, true)
-    this.checkParams(node)
-    this.strict = oldStrict
-  } else if (isArrowFunction) {
+      this.checkParams(node)
+      this.strict = oldStrict
+    }
+  }
+  else if (isArrowFunction) {
     this.checkParams(node)
   }
 }
 
 // Checks function params for various disallowed patterns such as using "eval"
 // or "arguments" and duplicate parameters.
-
 pp.checkParams = function(node) {
-    let nameHash = {}
-    for (let i = 0; i < node.params.length; i++)
-      this.checkLVal(node.params[i], true, nameHash)
+  let nameHash = {}
+    for (let i = 0; i < node.params.length; i++) {
+    this.checkLVal(node.params[i], true, nameHash)
+    }
 }
 
 // Parses a comma-separated list of expressions, and returns them as
@@ -631,7 +703,6 @@
 // `allowEmpty` can be turned on to allow subsequent commas with
 // nothing in between them to be parsed as `null` (which is needed
 // for array literals).
-
 pp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
   let elts = [], first = true
   while (!this.eat(close)) {
@@ -640,17 +711,25 @@
       if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
         refDestructuringErrors.trailingComma = this.lastTokStart
       }
-      if (allowTrailingComma && this.afterTrailingComma(close)) break
-    } else first = false
+      if (allowTrailingComma && this.afterTrailingComma(close)) {
+        break
+      }
+    }
+    else {
+      first = false
 
-    let elt
-    if (allowEmpty && this.type === tt.comma)
-      elt = null
-    else if (this.type === tt.ellipsis)
-      elt = this.parseSpread(refDestructuringErrors)
-    else
-      elt = this.parseMaybeAssign(false, refDestructuringErrors)
-    elts.push(elt)
+      let elt
+      if (allowEmpty && this.type === tt.comma) {
+        elt = null
+        else if (this.type === tt.ellipsis) {
+          elt = this.parseSpread(refDestructuringErrors)
+          else {
+            elt = this.parseMaybeAssign(false, refDestructuringErrors)
+            elts.push(elt)
+          }
+        }
+      }
+    }
   }
   return elts
 }
@@ -658,36 +737,41 @@
 // Parse the next token as an identifier. If `liberal` is true (used
 // when parsing properties), it will also convert keywords into
 // identifiers.
-
 pp.parseIdent = function(liberal) {
   let node = this.startNode()
-  if (liberal && this.options.allowReserved == "never") liberal = false
-  if (this.type === tt.name) {
-    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&
+  if (liberal && this.options.allowReserved == "never") {
+    liberal = false
+    if (this.type === tt.name) {
+      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&
         (this.options.ecmaVersion >= 6 ||
-         this.input.slice(this.start, this.end).indexOf("\\") == -1))
-      this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved")
-    if (!liberal && this.inGenerator && this.value === "yield")
-      this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator")
-    node.name = this.value
-  } else if (liberal && this.type.keyword) {
-    node.name = this.type.keyword
-  } else {
-    this.unexpected()
+         this.input.slice(this.start, this.end).indexOf("\\") == -1)) {
+        this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved")
+        if (!liberal && this.inGenerator && this.value === "yield") {
+          this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator")
+          node.name = this.value
+        }
+      }
+    }
+    else if (liberal && this.type.keyword) {
+      node.name = this.type.keyword
+    }
+    else {
+      this.unexpected()
+    }
   }
   this.next()
   return this.finishNode(node, "Identifier")
 }
 
 // Parses yield expression inside generator.
-
 pp.parseYield = function() {
   let node = this.startNode()
   this.next()
   if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {
     node.delegate = false
     node.argument = null
-  } else {
+  }
+  else {
     node.delegate = this.eat(tt.star)
     node.argument = this.parseMaybeAssign()
   }

--- themes/c4m/kapablo/build/node_modules/acorn/src/index.js
+++ PHP_CodeSniffer
@@ -1,4 +1,8 @@
-// Acorn is a tiny, fast JavaScript parser written in JavaScript.
+/**
+ * @file
+ * Acorn is a tiny, fast JavaScript parser written in JavaScript.
+ */
+
 //
 // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
 // various contributors and released under an MIT license.
@@ -17,8 +21,7 @@
 // [abstract syntax tree walker][walk], defined in other files.
 //
 // [dammit]: acorn_loose.js
-// [walk]: util/walk.js
-
+// [walk]: util/walk.js.
 import {Parser} from "./state"
 import "./parseutil"
 import "./statement"
@@ -44,7 +47,6 @@
 // API][api].
 //
 // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
-
 export function parse(input, options) {
   return new Parser(options, input).parse()
 }
@@ -52,7 +54,6 @@
 // This function tries to parse a single expression at a given
 // offset in a string. Useful for parsing mixed-language formats
 // that embed JavaScript expressions.
-
 export function parseExpressionAt(input, pos, options) {
   let p = new Parser(options, input, pos)
   p.nextToken()
@@ -61,7 +62,6 @@
 
 // Acorn is organized as a tokenizer and a recursive-descent parser.
 // The `tokenizer` export provides an interface to the tokenizer.
-
 export function tokenizer(input, options) {
   return new Parser(options, input)
 }

--- themes/c4m/kapablo/build/node_modules/acorn/src/location.js
+++ PHP_CodeSniffer
@@ -1,3 +1,7 @@
+/**
+ * @file
+ */
+
 import {Parser} from "./state"
 import {Position, getLineInfo} from "./locutil"
 
@@ -8,7 +12,6 @@
 // the location of the error, attaches the position to the end
 // of the error message, and then raises a `SyntaxError` with that
 // message.
-
 pp.raise = function(pos, message) {
   let loc = getLineInfo(this.input, pos)
   message += " (" + loc.line + ":" + loc.column + ")"

--- themes/c4m/kapablo/build/node_modules/acorn/src/locutil.js
+++ PHP_CodeSniffer
@@ -1,8 +1,11 @@
+/**
+ * @file
+ */
+
 import {lineBreakG} from "./whitespace"
 
 // These are used when `options.locations` is on, for the
 // `startLoc` and `endLoc` properties.
-
 export class Position {
   constructor(line, col) {
     this.line = line
@@ -18,25 +21,26 @@
   constructor(p, start, end) {
     this.start = start
     this.end = end
-    if (p.sourceFile !== null) this.source = p.sourceFile
+    if (p.sourceFile !== null) {
+      this.source = p.sourceFile
+    }
   }
-}
 
-// The `getLineInfo` function is mostly useful when the
-// `locations` option is off (for performance reasons) and you
-// want to find the line/column position for a given character
-// offset. `input` should be the code string that the offset refers
-// into.
-
-export function getLineInfo(input, offset) {
-  for (let line = 1, cur = 0;;) {
-    lineBreakG.lastIndex = cur
-    let match = lineBreakG.exec(input)
-    if (match && match.index < offset) {
-      ++line
-      cur = match.index + match[0].length
-    } else {
-      return new Position(line, offset - cur)
+  // The `getLineInfo` function is mostly useful when the
+  // `locations` option is off (for performance reasons) and you
+  // want to find the line/column position for a given character
+  // offset. `input` should be the code string that the offset refers
+  // into.
+  export function getLineInfo(input, offset) {
+    for (let line = 1, cur = 0;;) {
+      lineBreakG.lastIndex = cur
+      let match = lineBreakG.exec(input)
+      if (match && match.index < offset) {
+        ++line
+        cur = match.index + match[0].length
+      }
+      else {
+        return new Position(line, offset - cur)
+      }
     }
-  }
-}
+  } }

--- themes/c4m/kapablo/build/node_modules/acorn/src/loose/acorn_loose.js
+++ PHP_CodeSniffer
@@ -0,0 +1,3 @@
+/**
+ * @file
+ */

--- themes/c4m/kapablo/build/node_modules/acorn/src/loose/expression.js
+++ PHP_CodeSniffer
@@ -1,3 +1,7 @@
+/**
+ * @file
+ */
+
 import {LooseParser} from "./state"
 import {isDummy} from "./parseutil"
 import {tokTypes as tt} from ".."
@@ -5,18 +9,20 @@
 const lp = LooseParser.prototype
 
 lp.checkLVal = function(expr) {
-  if (!expr) return expr
-  switch (expr.type) {
-  case "Identifier":
-  case "MemberExpression":
-    return expr
-
-  case "ParenthesizedExpression":
-    expr.expression = this.checkLVal(expr.expression)
+  if (!expr) {
     return expr
+    switch (expr.type) {
+      case "Identifier":
+      case "MemberExpression":
+        return expr
+
+      case "ParenthesizedExpression":
+        expr.expression = this.checkLVal(expr.expression)
+        return expr
 
-  default:
-    return this.dummyIdent()
+      default:
+        return this.dummyIdent()
+    }
   }
 }
 
@@ -26,8 +32,10 @@
   if (this.tok.type === tt.comma) {
     let node = this.startNodeAt(start)
     node.expressions = [expr]
-    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn))
-    return this.finishNode(node, "SequenceExpression")
+    while (this.eat(tt.comma)) {
+      node.expressions.push(this.parseMaybeAssign(noIn))
+      return this.finishNode(node, "SequenceExpression")
+    }
   }
   return expr
 }
@@ -48,7 +56,8 @@
     if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type != tt.star && !this.tok.type.startsExpr)) {
       node.delegate = false
       node.argument = null
-    } else {
+    }
+    else {
       node.delegate = this.eat(tt.star)
       node.argument = this.parseMaybeAssign()
     }
@@ -88,22 +97,25 @@
 }
 
 lp.parseExprOp = function(left, start, minPrec, noIn, indent, line) {
-  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left
-  let prec = this.tok.type.binop
-  if (prec != null && (!noIn || this.tok.type !== tt._in)) {
-    if (prec > minPrec) {
-      let node = this.startNodeAt(start)
-      node.left = left
-      node.operator = this.tok.value
-      this.next()
-      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
-        node.right = this.dummyIdent()
-      } else {
-        let rightStart = this.storeCurrentPos()
-        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line)
+  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
+    return left
+    let prec = this.tok.type.binop
+    if (prec != null && (!noIn || this.tok.type !== tt._in)) {
+      if (prec > minPrec) {
+        let node = this.startNodeAt(start)
+        node.left = left
+        node.operator = this.tok.value
+        this.next()
+        if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
+          node.right = this.dummyIdent()
+        }
+        else {
+          let rightStart = this.storeCurrentPos()
+          node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line)
+        }
+        this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression")
+        return this.parseExprOp(node, start, minPrec, noIn, indent, line)
       }
-      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression")
-      return this.parseExprOp(node, start, minPrec, noIn, indent, line)
     }
   }
   return left
@@ -113,19 +125,25 @@
   let start = this.storeCurrentPos(), expr
   if (this.tok.type.prefix) {
     let node = this.startNode(), update = this.tok.type === tt.incDec
-    if (!update) sawUnary = true
-    node.operator = this.tok.value
-    node.prefix = true
-    this.next()
-    node.argument = this.parseMaybeUnary(true)
-    if (update) node.argument = this.checkLVal(node.argument)
-    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
-  } else if (this.tok.type === tt.ellipsis) {
+    if (!update) {
+      sawUnary = true
+      node.operator = this.tok.value
+      node.prefix = true
+      this.next()
+      node.argument = this.parseMaybeUnary(true)
+      if (update) {
+        node.argument = this.checkLVal(node.argument)
+        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
+      }
+    }
+  }
+  else if (this.tok.type === tt.ellipsis) {
     let node = this.startNode()
     this.next()
     node.argument = this.parseMaybeUnary(sawUnary)
     expr = this.finishNode(node, "SpreadElement")
-  } else {
+  }
+  else {
     expr = this.parseExprSubscripts()
     while (this.tok.type.postfix && !this.canInsertSemicolon()) {
       let node = this.startNodeAt(start)
@@ -156,22 +174,27 @@
 lp.parseSubscripts = function(base, start, noCalls, startIndent, line) {
   for (;;) {
     if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
-      if (this.tok.type == tt.dot && this.curIndent == startIndent)
+      if (this.tok.type == tt.dot && this.curIndent == startIndent) {
         --startIndent
-      else
-        return base
+        else {
+          return base
+        }
+      }
     }
 
     if (this.eat(tt.dot)) {
       let node = this.startNodeAt(start)
       node.object = base
-      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine())
+      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
         node.property = this.dummyIdent()
-      else
-        node.property = this.parsePropertyAccessor() || this.dummyIdent()
-      node.computed = false
-      base = this.finishNode(node, "MemberExpression")
-    } else if (this.tok.type == tt.bracketL) {
+        else {
+          node.property = this.parsePropertyAccessor() || this.dummyIdent()
+          node.computed = false
+          base = this.finishNode(node, "MemberExpression")
+        }
+      }
+    }
+    else if (this.tok.type == tt.bracketL) {
       this.pushCx()
       this.next()
       let node = this.startNodeAt(start)
@@ -181,17 +204,20 @@
       this.popCx()
       this.expect(tt.bracketR)
       base = this.finishNode(node, "MemberExpression")
-    } else if (!noCalls && this.tok.type == tt.parenL) {
+    }
+    else if (!noCalls && this.tok.type == tt.parenL) {
       let node = this.startNodeAt(start)
       node.callee = base
       node.arguments = this.parseExprList(tt.parenR)
       base = this.finishNode(node, "CallExpression")
-    } else if (this.tok.type == tt.backQuote) {
+    }
+    else if (this.tok.type == tt.backQuote) {
       let node = this.startNodeAt(start)
       node.tag = base
       node.quasi = this.parseTemplate()
       base = this.finishNode(node, "TaggedTemplateExpression")
-    } else {
+    }
+    else {
       return base
     }
   }
@@ -200,80 +226,80 @@
 lp.parseExprAtom = function() {
   let node
   switch (this.tok.type) {
-  case tt._this:
-  case tt._super:
-    let type = this.tok.type === tt._this ? "ThisExpression" : "Super"
-    node = this.startNode()
-    this.next()
-    return this.finishNode(node, type)
+    case tt._this:
+    case tt._super:
+      let type = this.tok.type === tt._this ? "ThisExpression" : "Super"
+      node = this.startNode()
+      this.next()
+      return this.finishNode(node, type)
 
-  case tt.name:
-    let start = this.storeCurrentPos()
-    let id = this.parseIdent()
-    return this.eat(tt.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id
-
-  case tt.regexp:
-    node = this.startNode()
-    let val = this.tok.value
-    node.regex = {pattern: val.pattern, flags: val.flags}
-    node.value = val.value
-    node.raw = this.input.slice(this.tok.start, this.tok.end)
-    this.next()
-    return this.finishNode(node, "Literal")
+    case tt.name:
+      let start = this.storeCurrentPos()
+      let id = this.parseIdent()
+      return this.eat(tt.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id
+
+    case tt.regexp:
+      node = this.startNode()
+      let val = this.tok.value
+      node.regex = {pattern: val.pattern, flags: val.flags}
+      node.value = val.value
+      node.raw = this.input.slice(this.tok.start, this.tok.end)
+      this.next()
+      return this.finishNode(node, "Literal")
 
-  case tt.num: case tt.string:
-    node = this.startNode()
-    node.value = this.tok.value
-    node.raw = this.input.slice(this.tok.start, this.tok.end)
-    this.next()
-    return this.finishNode(node, "Literal")
+    case tt.num: case tt.string:
+        node = this.startNode()
+        node.value = this.tok.value
+        node.raw = this.input.slice(this.tok.start, this.tok.end)
+        this.next()
+      return this.finishNode(node, "Literal")
+
+    case tt._null: case tt._true: case tt._false:
+          node = this.startNode()
+          node.value = this.tok.type === tt._null ? null : this.tok.type === tt._true
+          node.raw = this.tok.type.keyword
+          this.next()
+      return this.finishNode(node, "Literal")
 
-  case tt._null: case tt._true: case tt._false:
-    node = this.startNode()
-    node.value = this.tok.type === tt._null ? null : this.tok.type === tt._true
-    node.raw = this.tok.type.keyword
-    this.next()
-    return this.finishNode(node, "Literal")
+    case tt.parenL:
+      let parenStart = this.storeCurrentPos()
+      this.next()
+      let inner = this.parseExpression()
+      this.expect(tt.parenR)
+      if (this.eat(tt.arrow)) {
+        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (isDummy(inner) ? [] : [inner]))
+      }
+      if (this.options.preserveParens) {
+        let par = this.startNodeAt(parenStart)
+        par.expression = inner
+        inner = this.finishNode(par, "ParenthesizedExpression")
+      }
+      return inner
 
-  case tt.parenL:
-    let parenStart = this.storeCurrentPos()
-    this.next()
-    let inner = this.parseExpression()
-    this.expect(tt.parenR)
-    if (this.eat(tt.arrow)) {
-      return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (isDummy(inner) ? [] : [inner]))
-    }
-    if (this.options.preserveParens) {
-      let par = this.startNodeAt(parenStart)
-      par.expression = inner
-      inner = this.finishNode(par, "ParenthesizedExpression")
-    }
-    return inner
-
-  case tt.bracketL:
-    node = this.startNode()
-    node.elements = this.parseExprList(tt.bracketR, true)
-    return this.finishNode(node, "ArrayExpression")
+    case tt.bracketL:
+      node = this.startNode()
+      node.elements = this.parseExprList(tt.bracketR, true)
+      return this.finishNode(node, "ArrayExpression")
 
-  case tt.braceL:
-    return this.parseObj()
+    case tt.braceL:
+      return this.parseObj()
 
-  case tt._class:
-    return this.parseClass()
+    case tt._class:
+      return this.parseClass()
 
-  case tt._function:
-    node = this.startNode()
-    this.next()
-    return this.parseFunction(node, false)
+    case tt._function:
+      node = this.startNode()
+      this.next()
+      return this.parseFunction(node, false)
 
-  case tt._new:
-    return this.parseNew()
+    case tt._new:
+      return this.parseNew()
 
-  case tt.backQuote:
-    return this.parseTemplate()
+    case tt.backQuote:
+      return this.parseTemplate()
 
-  default:
-    return this.dummyIdent()
+    default:
+      return this.dummyIdent()
   }
 }
 
@@ -289,7 +315,8 @@
   node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line)
   if (this.tok.type == tt.parenL) {
     node.arguments = this.parseExprList(tt.parenR)
-  } else {
+  }
+  else {
     node.arguments = []
   }
   return this.finishNode(node, "NewExpression")
@@ -317,7 +344,8 @@
     node.expressions.push(this.parseExpression())
     if (this.expect(tt.braceR)) {
       curElt = this.parseTemplateElement()
-    } else {
+    }
+    else {
       curElt = this.startNode()
       curElt.value = {cooked: '', raw: ''}
       curElt.tail = true
@@ -334,7 +362,9 @@
   this.pushCx()
   let indent = this.curIndent + 1, line = this.curLineStart
   this.eat(tt.braceL)
-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart }
+  if (this.curIndent + 1 < indent) {
+    indent = this.curIndent; line = this.curLineStart
+  }
   while (!this.closes(tt.braceR, indent, line)) {
     let prop = this.startNode(), isGenerator, start
     if (this.options.ecmaVersion >= 6) {
@@ -344,21 +374,28 @@
       isGenerator = this.eat(tt.star)
     }
     this.parsePropertyName(prop)
-    if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) this.next(); this.eat(tt.comma); continue }
+    if (isDummy(prop.key)) {
+      if (isDummy(this.parseMaybeAssign())) {
+        this.next();
+      } this.eat(tt.comma); continue
+    }
     if (this.eat(tt.colon)) {
       prop.kind = "init"
       prop.value = this.parseMaybeAssign()
-    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === tt.parenL || this.tok.type === tt.braceL)) {
+    }
+    else if (this.options.ecmaVersion >= 6 && (this.tok.type === tt.parenL || this.tok.type === tt.braceL)) {
       prop.kind = "init"
       prop.method = true
       prop.value = this.parseMethod(isGenerator)
-    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
+    }
+    else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
                !prop.computed && (prop.key.name === "get" || prop.key.name === "set") &&
                (this.tok.type != tt.comma && this.tok.type != tt.braceR)) {
       prop.kind = prop.key.name
       this.parsePropertyName(prop)
       prop.value = this.parseMethod(false)
-    } else {
+    }
+    else {
       prop.kind = "init"
       if (this.options.ecmaVersion >= 6) {
         if (this.eat(tt.eq)) {
@@ -367,10 +404,12 @@
           assign.left = prop.key
           assign.right = this.parseMaybeAssign()
           prop.value = this.finishNode(assign, "AssignmentExpression")
-        } else {
+        }
+        else {
           prop.value = prop.key
         }
-      } else {
+      }
+      else {
         prop.value = this.dummyIdent()
       }
       prop.shorthand = true
@@ -381,9 +420,11 @@
   this.popCx()
   if (!this.eat(tt.braceR)) {
     // If there is no closing brace, make the node span to the start
-    // of the next token (this is useful for Tern)
+    // of the next token (this is useful for Tern).
     this.last.end = this.tok.start
-    if (this.options.locations) this.last.loc.end = this.tok.loc.start
+    if (this.options.locations) {
+      this.last.loc.end = this.tok.loc.start
+    }
   }
   return this.finishNode(node, "ObjectExpression")
 }
@@ -395,7 +436,8 @@
       prop.key = this.parseExpression()
       this.expect(tt.bracketR)
       return
-    } else {
+    }
+    else {
       prop.computed = false
     }
   }
@@ -404,16 +446,20 @@
 }
 
 lp.parsePropertyAccessor = function() {
-  if (this.tok.type === tt.name || this.tok.type.keyword) return this.parseIdent()
+  if (this.tok.type === tt.name || this.tok.type.keyword) {
+    return this.parseIdent()
+  }
 }
 
 lp.parseIdent = function() {
   let name = this.tok.type === tt.name ? this.tok.value : this.tok.type.keyword
-  if (!name) return this.dummyIdent()
-  let node = this.startNode()
-  this.next()
-  node.name = name
-  return this.finishNode(node, "Identifier")
+  if (!name) {
+    return this.dummyIdent()
+    let node = this.startNode()
+    this.next()
+    node.name = name
+    return this.finishNode(node, "Identifier")
+  }
 }
 
 lp.initFunction = function(node) {
@@ -427,38 +473,46 @@
 
 // Convert existing expression atom to assignable pattern
 // if possible.
-
 lp.toAssignable = function(node, binding) {
   if (!node || node.type == "Identifier" || (node.type == "MemberExpression" && !binding)) {
-    // Okay
-  } else if (node.type == "ParenthesizedExpression") {
+    // Okay.
+  }
+  else if (node.type == "ParenthesizedExpression") {
     node.expression = this.toAssignable(node.expression, binding)
-  } else if (this.options.ecmaVersion < 6) {
+  }
+  else if (this.options.ecmaVersion < 6) {
     return this.dummyIdent()
-  } else if (node.type == "ObjectExpression") {
+  }
+  else if (node.type == "ObjectExpression") {
     node.type = "ObjectPattern"
     let props = node.properties
-    for (let i = 0; i < props.length; i++)
+    for (let i = 0; i < props.length; i++) {
       props[i].value = this.toAssignable(props[i].value, binding)
-  } else if (node.type == "ArrayExpression") {
+    }
+  }
+  else if (node.type == "ArrayExpression") {
     node.type = "ArrayPattern"
     this.toAssignableList(node.elements, binding)
-  } else if (node.type == "SpreadElement") {
+  }
+  else if (node.type == "SpreadElement") {
     node.type = "RestElement"
     node.argument = this.toAssignable(node.argument, binding)
-  } else if (node.type == "AssignmentExpression") {
+  }
+  else if (node.type == "AssignmentExpression") {
     node.type = "AssignmentPattern"
     delete node.operator
-  } else {
+  }
+  else {
     return this.dummyIdent()
   }
   return node
 }
 
 lp.toAssignableList = function(exprList, binding) {
-  for (let i = 0; i < exprList.length; i++)
+  for (let i = 0; i < exprList.length; i++) {
     exprList[i] = this.toAssignable(exprList[i], binding)
-  return exprList
+    return exprList
+  }
 }
 
 lp.parseFunctionParams = function(params) {
@@ -487,7 +541,8 @@
 lp.parseExprList = function(close, allowEmpty) {
   this.pushCx()
   let indent = this.curIndent, line = this.curLineStart, elts = []
-  this.next() // Opening bracket
+  // Opening bracket.
+  this.next()
   while (!this.closes(close, indent + 1, line)) {
     if (this.eat(tt.comma)) {
       elts.push(allowEmpty ? null : this.dummyIdent())
@@ -495,9 +550,12 @@
     }
     let elt = this.parseMaybeAssign()
     if (isDummy(elt)) {
-      if (this.closes(close, indent, line)) break
-      this.next()
-    } else {
+      if (this.closes(close, indent, line)) {
+        break
+        this.next()
+      }
+    }
+    else {
       elts.push(elt)
     }
     this.eat(tt.comma)
@@ -505,9 +563,11 @@
   this.popCx()
   if (!this.eat(close)) {
     // If there is no closing brace, make the node span to the start
-    // of the next token (this is useful for Tern)
+    // of the next token (this is useful for Tern).
     this.last.end = this.tok.start
-    if (this.options.locations) this.last.loc.end = this.tok.loc.start
+    if (this.options.locations) {
+      this.last.loc.end = this.tok.loc.start
+    }
   }
   return elts
 }

--- themes/c4m/kapablo/build/node_modules/acorn/src/loose/index.js
+++ PHP_CodeSniffer
@@ -1,4 +1,8 @@
-// Acorn: Loose parser
+/**
+ * @file
+ * Acorn: Loose parser.
+ */
+
 //
 // This module provides an alternative parser (`parse_dammit`) that
 // exposes that same interface as `parse`, but will try to parse
@@ -28,7 +32,6 @@
 // and slower. Copying and editing the code allowed me to make
 // invasive changes and simplifications without creating a complicated
 // tangle.
-
 import * as acorn from ".."
 import {LooseParser, pluginsLoose} from "./state"
 import "./tokenize"

--- themes/c4m/kapablo/build/node_modules/acorn/src/loose/parseutil.js
+++ PHP_CodeSniffer
@@ -1 +1,6 @@
-export function isDummy(node) { return node.name == "✖" }
\ No newline at end of file
+/**
+ * @file
+ */
+
+export function isDummy(node) { return node.name == "✖"
+}

