<?php

/**
 * @file
 * Code for the C4M notifications feature.
 */

function c4m_user_notifications_load_includes() {
  module_load_include('inc', 'c4m_user_notifications', 'includes/c4m_user_notifications_handlers');
}

/**
 * Implements hook_entity_insert.
 *
 * Triggers email notification on new membership request for moderated groups.
 */
function c4m_user_notifications_entity_insert($entity, $type) {
  if ($type != 'og_membership') {
    return;
  }

  // Loading group/project to resolve it's membership type - moderated/open
  $node = node_load($entity->gid);
  $wrapper = entity_metadata_wrapper('node', $node);
  if ($wrapper->field_membership_open_request->value() != C4M_OG_MODERATED_GROUP) {
    // If not moderated group, return early
    return;
  }

  c4m_user_notifications_load_includes();
  c4m_user_notifications_moderated_group_new_membership_request($entity);
}

/**
 * Implements hook_entity_update.
 *
 * Triggers email notification for membership update.
 *
 * Notified states:
 *   Pending -> Accepted
 *   Pending -> Rejected
 */
function c4m_user_notifications_entity_update($entity, $type) {
  if ($type != 'og_membership') {
    return;
  }

  if (empty($entity->original)) {
    // Must have original state.
    return;
  }

  if ($entity->original->state != OG_STATE_PENDING) {
    // State change has to be initiated when state is Pending.
    return;
  }

  // Loading group/project to resolve it's membership type - moderated/open
  $node = node_load($entity->gid);
  $wrapper = entity_metadata_wrapper('node', $node);
  $moderated = $wrapper->field_membership_open_request->value();

  c4m_user_notifications_load_includes();

  switch($entity->state) {
    case OG_STATE_ACTIVE:
      if ($moderated == C4M_OG_MODERATED_GROUP ) {
        c4m_user_notifications_moderated_group_notify_user_membership_accepted($entity);
        c4m_user_notifications_moderated_group_notify_admins_membership_accepted($entity);
      }
      else if ($moderated == C4M_OG_OPEN_GROUP) {
        c4m_user_notifications_open_group_notify_user_membership_accepted($entity);
        c4m_user_notifications_open_group_notify_admins_membership_accepted($entity);
      }
      break;

    case OG_STATE_BLOCKED:
      if ($moderated == C4M_OG_MODERATED_GROUP ) {
        c4m_user_notifications_moderated_group_notify_user_membership_rejected($entity);
      }
      break;
  }
}

/**
 * Implements hook_entity_delete.
 *
 * Triggers email notification on membership cancelation request.
 */
function c4m_user_notifications_entity_delete($entity, $type) {
  if ($type != 'og_membership') {
    return;
  }

  // Loading group/project to resolve it's membership type - moderated/open
  $node = node_load($entity->gid);
  $wrapper = entity_metadata_wrapper('node', $node);
  if ($wrapper->field_membership_open_request->value() != C4M_OG_MODERATED_GROUP) {
    // If not moderated group, return early
    return;
  }

  // Loading current user.
  global $user;
  c4m_user_notifications_load_includes();

  if ($user->uid == $entity->etid) {
    // If current user is the one that's being removed.
    c4m_user_notifications_notify_admins_membership_canceled($entity);
  }
  else {
    // Membership was canceled by someone else -> group / site admin
    c4m_user_notifications_notify_user_membership_canceled($entity);
  }
}

/**
 * Implements hook_node_insert.
 *
 * Triggers email notification for new node (group/project), for status 'published'.
 */
function c4m_user_notifications_node_insert($node) {
  if ($node->type != 'group' && $node->type != 'project') {
    // Return early, if node type is not group/project.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $status = $wrapper->c4m_og_status->value();

  c4m_user_notifications_load_includes();
  if ($status == 'published') {
    c4m_user_notifications_group_status_set_published($node);
  }

}

/**
 * Implements hook_node_update.
 *
 * Triggers email notification for node (group/project) status update.
 */
function c4m_user_notifications_node_update($node) {
  if ($node->type != 'group' && $node->type != 'project') {
    // Return early, if node type is not group/project.
    return;
  }

  if (empty($node->original)) {
    // On node update, there must be $node->original
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper_original = entity_metadata_wrapper('node', $node->original);
  c4m_user_notifications_load_includes();

  $status = $wrapper->c4m_og_status->value();
  $prev_status = $wrapper_original->c4m_og_status->value();
  if ($status != $prev_status) {
    // If group status has changed
    switch ($status) {
      case 'published':
        if ($prev_status == 'archived' || $prev_status == 'unpublished' || $prev_status == 'deleted') {
          c4m_user_notifications_group_status_set_republished($node);
        }
        break;
      // Published -> Draft => Unpublished.
      case 'draft':
        if ($prev_status == 'published') {
          c4m_user_notifications_group_status_set_unpublished($node);
        }
        break;

      case 'archived':
        c4m_user_notifications_group_status_set_archived($node);
        break;
      // Soft delete.
      case 'deleted':
        c4m_user_notifications_group_status_set_softdeleted($node);
        break;
    }
  }

  $group_access = $wrapper->group_access->value();
  $prev_group_access = $wrapper_original->group_access->value();
  if ($group_access != $prev_group_access) {
    // if group access has changed (switch between Public and Private/Restricted).
    c4m_user_notifications_group_access_changed($node);
  }
  else if ($group_access == TRUE) {
    // Possible switch between Private and Restricted.
    $plug_node_access = empty($wrapper->pluggable_node_access->value());
    $prev_plug_node_access = empty($wrapper_original->pluggable_node_access->value());

    if ($plug_node_access != $prev_plug_node_access) {
      c4m_user_notifications_group_access_changed($node);
    }
    else {
      // Check if 'membership open' state was changed - part of group access as well.
      $membership_open = $wrapper->field_membership_open_request ->value();
      $prev_membership_open = $wrapper_original->field_membership_open_request ->value();

      if ($membership_open != $prev_membership_open) {
        c4m_user_notifications_group_access_changed($node);
      }
    }
  }

  $group_owner = $node->uid;
  $prev_group_owner = $node->original->uid;
  if ($group_owner != $prev_group_owner) {
    c4m_user_notifications_notify_prev_owner_owner_update($node);
    c4m_user_notifications_notify_new_owner_owner_update($node);
    c4m_user_notifications_notify_admins_owner_update($node);
  }
}

/**
 * Implements hook_node_delete.
 *
 * Triggers email notification for node (group/project) delete.
 */
function c4m_user_notifications_node_delete($node) {
  if ($node->type != 'group' && $node->type != 'project') {
    // Return early, if node type is not group/project.
    return;
  }

  c4m_user_notifications_load_includes();
  c4m_user_notifications_group_hard_deleted($node);
}

/**
 * Implements hook_comment_insert.
 *
 * Triggers email notification for comment insert.
 */
function c4m_user_notifications_comment_insert($comment) {
  c4m_user_notifications_load_includes();
  c4m_user_notifications_notify_user_commented($comment);
}

/**
 * Implements hook_user_delete.
 *
 * Triggers email notification for node (group/project) delete.
 */
function c4m_user_notifications_user_delete($account) {
  c4m_user_notifications_load_includes();
  c4m_user_notifications_notify_admins_user_deleted($account);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Triggers email notification when user is invited to group by admin.
 */
function c4m_user_notifications_form_og_ui_add_users_alter(&$form, &$form_state) {
  $form['#submit'][] = 'c4m_user_notifications_notify_user_invited_by_admin';
}


